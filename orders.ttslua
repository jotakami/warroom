#include constants/nations
#include constants/colors
#include constants/units
#include xml/orders
#include utils/debug

function onLoad(saved_state)
    Nation = self.getName():match('^(%a+)%s'):lower()
    Resources = getObjectFromGUID(Global.getTable('GUIDs').Nations[Nation].resources)
    if Nation ~= 'china' then Trades = {oil = 2, iron = 3, osr = 5} end
    NumOrders = Nation ~= 'china' and Nation ~= 'italy' and 9 or 6
    local assets = {}
    for _, asset in ipairs(UI.getCustomAssets()) do if asset.name == 'confirm'
        or asset.name == 'cancel' or asset.name == 'invalid' or asset.name == 'pact'
        or asset.name == 'pin' or asset.name == 'neutral' then table.insert(assets, asset) end end
    self.UI.setCustomAssets(assets)
    self.UI.setXmlTable(initXML(NumOrders / 3, Nation == 'china'))
    state = {}
    if saved_state ~= '' then loadSave(saved_state)
    else for _, label in ipairs{'resources', 'post_trade', 'cost', 'remaining'} do
        state[label] = {iron = 0, osr = 0}
        if Nation ~= 'china' then state[label].oil = 0 end
    end end
end

function onSave()
    local save_ok = Global.call('saveOK')
    if not save_ok then return '' end
    return JSON.encode(state)
end

function loadSave(saved_state)
    state = JSON.decode(saved_state)
    Wait.condition(function ()
        for i, move in pairs(state.moves or {}) do
            self.UI.setAttribute('command' .. i, 'text', move.command or '')
            self.UI.setAttribute('target' .. i, 'text', move.target or '')
        end
        if state.bid then self.UI.setAttribute('bid', 'text', state.bid) end
        if state.trade then for _, sign in ipairs{'plus', 'minus'} do
            if state.trade[sign] then toggleTrade(_, 'True', sign .. '-' .. state.trade[sign]) end
        end end
        for unit, data in pairs(state.production or {}) do
            if unit == 'cg' then for resource, value in pairs(data) do if resource ~= 'quantity' then
                updatePurchase(nil, value == 0 and '' or value, 'cg-' .. resource)
            end end else updatePurchase(nil, data.quantity == 0 and '' or data.quantity, unit .. '-purchase') end
    end end, || self.UI.getXml() ~= '')
end

-- GAME PHASE FUNCTIONS --

-- Phase 1: Direct National Economy

function setRound(data)
    self.UI.setValue('round', data[1])
    if Nation ~= 'china' then
        self.UI.hide('bid')
        for resource, _ in pairs(state.resources) do for _, label in ipairs{'trade', 'minus', 'plus'} do
            self.UI.hide(label .. '-' .. resource)
    end end end
    for i = 1, NumOrders do self.UI.hide('slash' .. i) end
    for _, id in ipairs{'commands', 'targets', 'purchases', 'post_trade', 'remaining'} do self.UI.hide(id) end
end

-- Phase 2: Strategic Planning

function writeOrders(params)
    local disrupted, resume = table.unpack(params)
    if Nation ~= 'china' then self.UI.setAttributes('bid', {active = true, visibility = getVis()}) end
    self.UI.setAttributes('commands', {active = true, visibility = getVis()})
    self.UI.setAttributes('targets', {active = true, visibility = getVis()})
    self.UI.setAttributes('orders-ready', {isOn = true, active = true, color = '#ffffff'})
    setOrders(false, not resume)
    if disrupted then for i = NumOrders - 2, NumOrders do
        self.UI.hide('command' .. i)
        self.UI.hide('target' .. i)
        self.UI.show('slash' .. i)
    end end
    if resume then for id, _ in pairs(state.invalid) do invalidOrders(id) end
    else state.invalid = {} end
end

function setOrders(lock, clear)
    if clear then state.moves = {} end
    for _, label in ipairs{'command', 'target'} do for i = 1, NumOrders do
        self.UI.setAttribute(label .. i, 'interactable', not lock)
        if clear then self.UI.setAttribute(label .. i, 'text', '')
    end end end
    if Nation ~= 'china' then
        self.UI.setAttribute('bid', 'interactable', not lock)
        if clear then
            state.bid = 0
            self.UI.setAttribute('bid', 'text', '')
    end end
end

function updateOrder(_, value, id)
    local part, index = id:match('%a+'), tonumber(id:match('%d'))
    if value == '' then
        value = nil
        validOrders(id)
    elseif part == 'command' then
        value = tonumber(value)
        if Global.call('validateCommand', {Nation, value}) then validOrders(id) else invalidOrders(id) end
    else
        local region = value:lower():gsub('-', ''):match('^[abcgijmnprtu]%d%d?$')
        if region and Global.call('validateRegion', {region}) then
            value = region:gsub('[aimp]', '%1-'):upper()
            validOrders(id)
        else invalidOrders(id) end
    end
    self.UI.setAttribute(id, 'text', value or '')
    state.moves[index] = state.moves[index] or {}
    state.moves[index][part] = value
end

function updateBid(_, value, id)
    self.UI.setAttribute(id, 'text', value)
    if value == '' or tonumber(value) <= state.resources.oil then
        state.bid = value ~= '' and tonumber(value) or 0
        validOrders(id)
    else invalidOrders(id) end
end

function validOrders(id)
    state.invalid[id] = nil
    self.UI.setAttribute(id, 'textColor', 'black')
    local invalid = false
    for _, flag in pairs(state.invalid) do invalid = invalid or flag end
    self.UI.setAttribute('orders-ready', 'interactable', not invalid)
end

function invalidOrders(id)
    state.invalid[id] = true
    self.UI.setAttribute(id, 'textColor', 'red')
    self.UI.setAttribute('orders-ready', 'interactable', false)
end

function toggleReady(value, id)
    self.UI.setAttributes(id, {isOn = value, color = value and '#ffffff' or '#80ff80'})
    Global.call('playerReady', {[Nation] = not value})
end

function ordersReady(_, value, id)
    value = value == 'True'
    setOrders(not value)
    toggleReady(value, id)
end

function revealBid()
    if Nation ~= 'china' then self.UI.setAttribute('bid', 'visibility', '') end
    self.UI.hide('orders-ready')
    return state.bid or 0
end

function payBid()
    if Nation ~= 'china' and state.bid > 0 then Resources.call('addResources', {oil = -state.bid})
    else Resources.call('broadcastUpdate') end
end

-- Phase 3: Movement Operations

function resolveOrders()
    self.UI.setAttribute('commands', 'visibility', '')
    self.UI.setAttribute('targets', 'visibility', '')
    self.UI.show('resolve')
    resolveOrder(1)
    return state.moves
end

function resolveOrder(num)
    if num <= NumOrders then
        local move = state.moves[num]
        if move and move.command and move.target then
            local confirm, cancel = {text = 'Confirm', icon = 'confirm', active = true}, {text = 'Cancel', icon = 'cancel'}
            cancelOrder = function ()
                Global.call('orderCanceled', {Nation, num})
                resolveOrder(num + 1)
            end
            local flag = Global.call('parseOrder', {Nation, num, move.command, move.target})
            if flag == 'pact' then confirm.text, confirm.icon, confirmOrder = 'Break pact', 'pact', function ()
                Global.call('breakPact', {Nation})
                resolveOrder(num)
            end elseif flag == 'neutral' then confirm.text, confirm.icon, confirmOrder = 'Invasion', 'neutral', function ()
                Global.call('invadeNeutral', {Nation, move.target})
                resolveOrder(num + 1)
            end else
                confirmOrder = function ()
                    if move.command > 9 and move.command < 20 then Global.call('setLanding', {Nation, move.command}) end
                    resolveOrder(num + 1)
                end
                if flag == 'invalid' then confirm.active, cancel.text, cancel.icon = false, 'Invalid', 'invalid'
                elseif flag == 'pinned' then confirm.active, cancel.text, cancel.icon = false, 'Pinned', 'pin'
                elseif flag == 'partial' then confirm.icon = 'pin'
            end end
            self.UI.setAttribute('resolve', 'offsetXY', (num - 1) % 3 * -260 .. ' ' .. math.floor((num - 1) / 3) * 356)
            self.UI.setAttributes('confirm', confirm)
            self.UI.setAttributes('cancel', cancel)
            Global.call('orderButtons', {Nation, num, confirm, cancel})
        else
            self.UI.show('slash' .. num)
            resolveOrder(num + 1)
    end else
        confirmOrder, cancelOrder = nil, nil
        self.UI.hide('resolve')
        Global.call('movementComplete', {nation = Nation})
    end
end

function otherReady(_, value, id)
    value = value == 'True'
    toggleReady(value, id)
end

function showReady()
    self.UI.setAttributes('other-ready', {isOn = true, active = true, color = 'white'})
end

function hideReady() self.UI.hide('other-ready') end

-- Phase 7: Production

function writeProduction(params)
    local trades, resume = params[1], params[2]
    for _, id in ipairs{'purchases', 'post_trade', 'remaining'} do self.UI.setAttributes(id, {active = true, visibility = getVis()}) end
    self.UI.setAttributes('production-ready', {isOn = true, active = true, color = 'white'})
    if not resume then
        state.production = {cg = {quantity = 0, iron = 0, osr = 0}}
        for unit, data in pairs(Units) do if data.cost and (Nation ~= 'china' or unit == 'infantry' or unit == 'artillery') then
            state.production[unit] = {quantity = 0}
            for resource, value in pairs(data.cost) do if value > 0 then state.production[unit][resource] = 0 end end
    end end end
    if Nation ~= 'china' then
        if not resume then state.trade, state.production.cg.oil = {routes = trades}, 0
        else state.trade.routes = trades end
        for resource, _ in pairs(state.resources) do for _, label in ipairs{'trade', 'plus', 'minus'} do
            self.UI.show(label .. '-' .. resource)
    end end end
    setProduction(false, not resume)
end

function setProduction(lock, clear)
    for unit, _ in pairs(state.production) do if unit == 'cg' then
        for resource, _ in pairs(state.resources) do
            self.UI.setAttribute('cg-' .. resource, 'interactable', not lock)
            if clear then
                self.UI.setAttribute('cg-' .. resource, 'text', '')
                updatePurchase(_, '', 'cg-' .. resource)
    end end else
        self.UI.setAttribute(unit .. '-purchase', 'interactable', not lock)
        if clear then
            self.UI.setAttribute(unit .. '-purchase', 'text', '')
            updatePurchase(_, '', unit .. '-purchase')
    end end end
    if state.trade then
        for resource, _ in pairs(state.resources) do for _, sign in ipairs{'plus', 'minus'} do
            self.UI.setAttribute(sign .. '-' .. resource, 'interactable', false)
            if clear then
                self.UI.setAttribute(sign .. '-' .. resource, 'isOn', false)
                if state.trade[sign] == resource then toggleTrade(_, 'False', sign .. '-' .. resource) end
        end end end
        for trade, can_trade in pairs(state.trade.routes) do if can_trade and not lock then
            for resource, _ in pairs(state.resources) do if trade == resource then
                self.UI.setAttribute('plus-' .. resource, 'interactable', true)
            else self.UI.setAttribute('minus-' .. resource, 'interactable', true)
    end end end end end
end

function toggleTrade(_, value, id)
    local sign, trade, color, other = id:match('(%a+)%-(%a+)')
    if sign == 'plus' then color, other = '#33ff338f', 'minus'
    else color, other = '#ff33338f', 'plus' end
    if value == 'True' then
        if sign == 'plus' or state.resources[trade] >= Trades[trade] then
            state.trade[sign] = trade
            if state.trade[other] == trade then state.trade[other] = nil end
            self.UI.setAttribute(id, 'color', color)
            resetToggle(other .. '-' .. trade)
            for resource, _ in pairs(state.resources) do if resource ~= trade then resetToggle(sign .. '-' .. resource) end end
        else resetToggle(id) end
    else
        state.trade[sign] = nil
        self.UI.setAttribute(id, 'color', '#ffffff33')
    end
    updateTrade()
end

function resetToggle(id)
    self.UI.setAttribute(id, 'isOn', 'False')
    self.UI.setAttribute(id, 'color', '#ffffff33')
end

function updateTrade()
    for resource, _ in pairs(state.resources) do
        local tid, rid = 'trade-' .. resource, 'post_trade-' .. resource
        state.post_trade[resource] = state.resources[resource]
        if state.trade then if resource == state.trade.plus then
            self.UI.setAttribute(tid, 'color', 'green')
            self.UI.setValue(tid, Trades[resource])
            if state.trade.minus then state.post_trade[resource] = state.resources[resource] + Trades[resource] end
        elseif resource == state.trade.minus then
            self.UI.setAttribute(tid, 'color', 'red')
            self.UI.setValue(tid, Trades[resource])
            if state.trade.plus then state.post_trade[resource] = state.resources[resource] - Trades[resource] end
        else self.UI.setValue(tid, '') end end
        self.UI.setValue(rid, state.post_trade[resource])
    end
    updateTotals()
end

function updatePurchase(_, value, id)
    self.UI.setAttribute(id, 'text', value)
    if value == '' then value = 0 else value = tonumber(value) end
    local unit_type = id:match('(%a+)%-')
    if unit_type == 'cg' then
        local total = 0
        state.production.cg[id:match('%-(%a+)')] = value
        for k, val in pairs(state.production.cg) do if k ~= 'quantity' then total = total + val end end
        state.production.cg.quantity = math.floor(total / 5)
        setIntValue('cg-purchase', state.production.cg.quantity)
        self.UI.setAttribute('cg-purchase', 'color', total % 5 > 0 and 'red' or 'black')
    else
        state.production[unit_type].quantity = value
        for resource, _ in pairs(state.resources) do if Units[unit_type].cost[resource] > 0 then
            state.production[unit_type][resource] = Units[unit_type].cost[resource] * value
            setIntValue(unit_type .. '-' .. resource, state.production[unit_type][resource])
    end end end
    updateTotals()
end

function updateTotals()
    state.cost = {iron = 0, osr = 0}
    if Nation ~= 'china' then state.cost.oil = 0 end
    local cg_spent, enable_ready = 0, true
    for unit_type, costs in pairs(state.production or {}) do for res, spent in pairs(costs) do if res ~= 'quantity' then
        state.cost[res], cg_spent = state.cost[res] + spent, cg_spent + (unit_type == 'cg' and spent or 0)
    end end end
    if cg_spent % 5 > 0 then enable_ready = false end
    for resource, total in pairs(state.cost) do
        state.remaining[resource] = state.post_trade[resource] - total
        setIntValue('cost-' .. resource, total)
        self.UI.setValue('remaining-' .. resource, state.remaining[resource])
        if state.remaining[resource] < 0 then
            self.UI.setAttribute('remaining-' .. resource, 'color', 'red')
            enable_ready = false
        else self.UI.setAttribute('remaining-' .. resource, 'color', 'black') end
    end
    self.UI.setAttribute('production-ready', 'interactable', enable_ready)
end

function productionReady(_, value, id)
    value = value == 'True'
    setProduction(not value)
    toggleReady(value, id)
end

function revealPurchases()
    for _, id in ipairs{'purchases', 'post_trade', 'remaining'} do self.UI.setAttribute(id, 'visibility', '') end
    self.UI.hide('production-ready')
    local purchases = {}
    for unit, t in pairs(state.production) do if t.quantity > 0 then purchases[unit] = t.quantity end end
    return purchases
end

function payPurchases()
    Resources.call('setResources', state.remaining)
    setProduction(true, true)
    if Nation ~= 'china' then for side, resource in pairs(state.trade) do if side ~= 'routes' then
        toggleTrade(nil, 'False', side .. '-' .. resource)
    end end end
end

-- INTERFACE FUNCTIONS --

function updateResources(data)
    state.resources = data
    for resource, value in pairs(data) do if resource ~= 'oil' or Nation ~= 'china' then
        self.UI.setValue('resources-' .. resource, value)
    end end
    updateTrade()
end

function breakPact(player)
    if not Pact then
        Pact = 1
        Wait.time(function () Pact = nil end, 2)
        broadcastToColor('Press 3 times rapidly to break the pact', player.color)
    else Pact = Pact + 1 end
    if Pact == 3 then Global.call('breakPact', {Nation}) end
end

-- HELPER FUNCTIONS --

function getVis()
    if Alliance[Nation] == 'axis' then return 'White|Green|Orange|Black'
    else return 'Blue|Brown|Red|Yellow|Black' end
end

function getIntValue(id)
    local value = self.UI.getValue(id)
    if value == '' then return 0 else return value or 0 end
end

function setIntValue(id, value)
    if value == 0 then self.UI.setValue(id, '') else self.UI.setValue(id, value) end
end
