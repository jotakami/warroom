-- -- Step 1: Flip embattled hotspots

function flipHotspots()
    for _, obj in ipairs(getAllObjects()) do if obj.getName() == 'hotspot' and obj.is_face_down then obj.flip() end end
    resolveMovement()
end

-- -- Step 2: Resolve movement in turn order

function resolveMovement()
    updateTracker('Resolve movement orders', '3 - Movement Operations')
    UI.show('movement')
    movementComplete = |data| resolveOrders(state.turn_order[state.turn_order[data.nation] + 1])
    resolveOrders(state.turn_order[1])
end

function resolveOrders(nation)
    UI.setAttribute('movement-nation', 'image', nation)
    if not nation then
        UI.hide('movement')
        movementComplete = nil
        deployCarrierFighters()
    else state.objects.orders[nation].call('resolveOrders') end
end

function evaluateOrder(params)
    local nation, id, target = params[1], tonumber(params[2]), params[3]:lower():gsub('-', '')
    local command = state.objects.commands[nation][id]
    local region = getRegion(command)
    UI.setValue('movement-order', command.getName():match('^[^\n]+'):gsub('%b[]', '') .. ' moves to ' .. params[3])
    if not state.pact_broken then
        if nation == 'japan' or nation == 'ussr' then
            local other = nation == 'japan' and 'ussr' or 'japan'
            if getOwnership(target) == other then return 'pact' end
        else
            local ally, other = isAxis(nation) and 'japan' or 'other', isAxis(nation) and 'ussr' or 'japan'
            if getOwnership(region) == ally and getOwnership(target) == other then return 'pact' end
        end
    end
    -- check pathing to see if command can move
end

function commandMoved(params)
    debug('Command moved, nation=', params.nation, ', command=', params.command)
    local nation = params.nation
    local is_axis, region = isAxis(nation), getRegion(state.objects.commands[nation][params.command])
    if params.command > 19 and getOwnership(region) == 'neutral' and (is_axis or not Map.data.regions[region].allied) then
        neutralInvasion(region, nation, is_axis and 'allies' or 'axis')
    end
end

function neutralInvasion(region, invader, other)
    debug('Neutral ', properName(region), ' was invaded')
    local data = Map.data.regions[region]
    local commands, min, owner = getAllCommands(), 8
    for _, nation in ipairs(mapBFS(region, |target| target:match('%a%d+(%g?)') ~= '^', function (r, d, v)
        if v.d and d > v.d then
            local result = {}
            for nation, side in pairs(Alliance) do if side == other and v[nation] then table.insert(result, nation) end end
            v.result = result
        elseif commands[r] and commands[r][other].army then for _, c in ipairs(commands[r][other].army) do
            local nation = commandNation(c)
            if state.pact_broken or (invader ~= 'japan' or nation ~= 'ussr') and (invader ~= 'ussr' or nation ~= 'japan') then
                v[nation], v.d = true, d
        end end end
        v[r] = true
    end)) do if state.turn_order[nation] < min then owner, min = nation, state.turn_order[nation] end end
    local pos = Map.obj.positionToWorld({data.centroid[1], 0.6, data.centroid[2]})
    local rot = vector(0, Map.obj.call('rotationToCenter', data.centroid), 0)
    local callback = function (units)
        getObjectFromGUID(GUIDs.Nations[owner].flag_bag).takeObject({
            position = pos, rotation = rot,
            callback_function = function (flag)
                mergeStack(flag, units)
                state.objects.commands[owner][999] = flag
                state.objects.flags[region] = flag
        end})
        local deck, index = state.objects.neutrals
        for _, card in ipairs(deck.getObjects()) do if card.name:find(region:upper()) then index = card.index break end end
        deck.takeObject({
            index = index,
            position = deck.getPosition() + vector(0, 3, 0),
            callback_function = |card| giveCard(card, owner)
        })
    end
    if data.army then buildStack(data.army, pos, rot, true, function (units)
        pos = pos + vector(0, 2, 0)
        callback(units)
    end) else callback() end
end

-- -- Step 3: Carrier fighter movement

function deployCarrierFighters()
    updateTracker('Carrier fighter movement')
    local fighterBag = getObjectFromGUID(GUIDs.Bags.Units.cfighter)
    local delay, ready = 0, {}
    for nation, commands in pairs(state.objects.commands) do
        updateStatus(nation, true)
        for i = 1, 9, 1 do if not commands[i] then break else
            local count = commands[i].getName():match('(%d+)%s%[%w+%]Carrier')
            if count then
                local rotation, bump = commands[i].getRotation(), 0
                if isAxis(nation) then rotation, bump = rotation + vector(0, 0, 180), 0.22 end
                state.objects.cfighters[nation] = {}
                state.objects.orders[nation].call('cfighterMovement')
                ready[nation] = false
                updateStatus(nation, false)
                for j = 1, count, 1 do
                    Wait.time(function () fighterBag.takeObject({
                        position = commands[i].getPosition() + vector(0, j * 0.25 + bump, 0),
                        rotation = rotation,
                        callback_function = function (obj)
                            obj.setVar('nation', nation)
                            obj.highlightOn(colorTable(Colors[nation]))
                            table.insert(state.objects.cfighters[nation], obj)
                        end
                    }) end, delay)
                    delay = delay + 0.15
    end end end end end
    playerReady = function (data) for nation, value in pairs(data) do
        ready[nation] = value
        updateStatus(nation, value)
        for _, cfighter in ipairs(state.objects.cfighters[nation]) do
            if value then cfighter.highlightOff()
            else cfighter.highlightOn(colorTable(Colors[nation])) end
    end end end
    Wait.condition(function ()
        playerReady = nil
        for nation, _ in pairs(ready) do state.objects.orders[nation].call('cfighterDone') end
        combatOperations()
    end, function ()
        for _, value in pairs(ready) do if not value then return false end end
        return true
    end)
end
