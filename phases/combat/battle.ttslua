Combat.Battle = {}
setmetatable(Combat.Battle, {__call = function (t, hotspot, commands)
    local T = {hotspot = hotspot}
    setmetatable(T, {__index = t})
    T.resume = coroutine.wrap(|...| T:main(...))
    return T.resume(commands)
end, __index = Combat})

function Combat.Battle:main(commands)
    local region, board = Map.regions[self.hotspot.region]
    local mode = region.is_sea and 'sea' or 'land'
    if not rawget(Battle.left, 'combat') then board = Battle.left end
    if not rawget(Battle.right, 'combat') and (not board or Battle.right:mode() == mode) then board = Battle.right end
    if board == nil then return true end
    setGlow(self.hotspot, Color.red)
    board:initializeCombat(self)
    local aux_data = board:placeUnits(commands)
    board:setAdvantages()
    local initiative, i = self:getInitiative(commands), 0
    debug(initiative .. ' has initiative')
    for _, side in ipairs{initiative, Nations.other[initiative]} do
        board.UI.setAttributes(side .. '-confirm', {text = 'Ready', textColor = 'white'})
        board.UI.show(side .. '-confirm-panel')
        debug('Waiting for ready button...')
        local glow = Wait.time(function ()
            local tint = Color.black:lerp(color(0.4, 0.4, 0.4), (i < 10 and i or 20 - i) / 10)
            i = (i + 1) % 20
            board.UI.setAttribute(side .. '-confirm-panel', 'color', tint:toXml(false))
        end, 0.08, -1)
        board:lockStances(coroutine.yield())
        board.UI.setAttribute(side .. '-confirm', 'interactable', false)
        Wait.stop(glow)
        board.UI.setAttribute(side .. '-confirm-panel', 'color', '#404040')
    end
    board:stage('air', initiative)
    board.zones_active = false
    if mode == 'land' then
        board:stage('bomb', initiative)
        board:stage('ground', initiative)
    else board:stage('surface', initiative) end
    board:repairs()
    Promise.all(board:replaceCommands(), board:losses()):next(function (commands)
        stopGlow(self.hotspot)
        if mode == 'sea' and aux_data then for side, force in pairs(aux_data) do
            commands[side].land = force
        end end
        self.resume(commands)
    end)
    board:reset()
    self:debrief(coroutine.yield(), mode == 'land' and aux_data or nil)
end

function Combat.Battle:getInitiative(sides)
    debug('Determining initiative')
    local initiative = {}
    for side, forces in pairs(sides) do
        initiative[side] = 0
        for force, commands in pairs(forces) do for _, command in ipairs(commands) do
            initiative[side] = math.max(initiative[side], turnOrder[command.nation])
    end end end
    return initiative.axis > initiative.allies and 'allies' or 'axis'
end
