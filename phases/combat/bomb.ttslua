function resolveBombing(hotspot)
    local region, bombers = getRegion(hotspot), 0
    local commands = getCommands(region)
    for _, command in ipairs(commands.axis.air or commands.allies.air) do
        bombers = bombers + tonumber(command.getName():match('(%d+) %b[]Bomber') or 0)
    end
    debug('Resolving strategic bombing in ', region, ' with ', bombers, ' bombers')
    rollBombers(hotspot, getBombTargets(region), bombers - 1, function ()
        debriefAirCommands(commands)
        returnPiece(hotspot)
        clearHotspot(region)
    end)
end

function rollBombers(hotspot, targets, remaining, callback)
    local offset = (Map.obj.positionToLocal(hotspot.getPosition()) - Map.data.center):setAt('y', 0):normalized()
    local shift, positions = (offset * 1.4):rotateOver('y', 90), {}
    local region, anchor = getRegion(hotspot), hotspot.getPosition() + vector(0, 1.8, 0) + offset - shift * 2.5
    for i = 1, 4 do table.insert(positions, anchor + shift * i) end
    rollDice(positions, function (dice) Wait.time(function ()
        table.sort(dice, |a, b| DiceOrder[getDieColor(a)] < DiceOrder[getDieColor(b)])
        for i, die in ipairs(dice) do die.setPositionSmooth(positions[i]) end
        self.setVar('assignBomb' .. region, function (_, val, guid)
            local color, target = val:match('(%a+)%-(%a+)')
            local die = getObjectFromGUID(guid)
            stopBlinker(die)
            die.destruct()
            hotspot.UI.setXml('')
            bombHit(region, target, hotspot.getPosition() + vector(0, 1, 0))
            targets[color][target] = targets[color][target] > 1 and targets[color][target] - 1 or nil
            assignBombDice(dice, targets, hotspot, remaining, callback)
        end)
        assignBombDice(dice, targets, hotspot, remaining, callback)
    end, 1) end)
end

function assignBombDice(dice, targets, hotspot, remaining, callback)
    local waiting
    while not waiting do if #dice == 0 then
        waiting = Wait.time(function ()
            if remaining == 0 then debug('Last bomber complete') callback()
            else debug('Rolling next bomber') rollBombers(hotspot, targets, remaining - 1, callback) end
        end, 1)
    else
        local die = table.remove(dice, 1)
        local hit_color, valid, count = getDieColor(die), {}, 0
        for color, hit_types in pairs(targets) do if hit_color == 'black' or hit_color == color then
            for hit_type, _ in pairs(hit_types) do count, valid[color] = count + 1, hit_types end
        end end
        debug('Assigning ', hit_color, ' bomb hit, ', count, ' valid targets')
        if count > 0 then
            setBlinker(die)
            createHitButtons(hotspot, valid, die.getGUID())
            waiting = true
        else die.destruct() end
    end end
end
