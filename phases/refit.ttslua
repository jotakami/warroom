Refit = Phase()

function Refit:main()
    HUD.updateTracker('Land air commands', '5 - Refit & Deploy', 'landing')
    HUD.updateTurn()
    HUD.resetStatus()
    local readied, ps, deploy = {}, {}, {}
    if state.phase < 5 or state.step < 2 then
        state.phase, state.step = 5, 1
        HUD.close('combat')
        for _, cfighter in ipairs(Commands.cfighters) do if cfighter.obj.memo ~= nil then stash(cfighter) end end
        Commands.cfighters = {}
        debug('Removed remaining carrier fighters')
        for command in Commands:all() do if command.force == 'fleet' and #command.getJoints() > 0 then
            debug('Removing dive token from ', command.nation, ' ', command.id)
            stash(getObjectFromGUID(command.getJoints()[1].joint_object_guid))
            command.jointTo()
        elseif command.force == 'air' and (#command.getJoints() > 0 or command.memo) then
            debug('Removing arrow tag from ', command.nation, ' ', command.id)
            if #command.getJoints() > 0 then
                stash(getObjectFromGUID(command.getJoints()[1].joint_object_guid))
                command.jointTo()
            end
            command.obj.memo, readied[command.nation] = command.memo or command:region(), false
            setGlow(command, Color[command.nation])
        end end
        for _, nation in turnOrder() do if readied[nation] == false then
            HUD.updateStatus(nation, false)
            Orders[nation]:enableReady(|...| self.resume(...))
        else HUD.updateStatus(nation, true) end end
        Phase.readyLoop(readied, next(readied) == nil, function (nation, ready)
            local invalid
            for _, command in pairs(Commands[nation]) do if command.memo then if ready then
                if not command:region() then command.obj.memo = nil else
                    local source, dest = Map.regions[command.memo], Map.regions[command:region()]
                    debug(command.nation, ' ', command.id, ' moves from ', source.id, ' to ', dest.id)
                    if dest.is_sea or not Movement:airMovement(command.nation, source, dest)
                            or dest:side() ~= 'neutral' and dest:side() ~= Nations[command.nation].side
                            or dest:side() == 'neutral' and (Nations[command.nation]:isAxis() or not dest.allied) then
                        invalid = true
                        setPulse(command, Color.red)
                        Wait.time(|| stopPulse(command), 6)
                end end
                stopGlow(command)
            else setGlow(command, Color[nation]) end end end
            if invalid then return false end
        end)
    end
    for command in Commands:all() do command.obj.memo = nil end
    HUD.updateTracker('Deploy units and reorganize commands', nil, 'deploy')
    HUD.resetStatus()
    state.step, readied = 2, {}
    for _, nation in turnOrder() do
        readied[nation], deploy[nation] = false, {}
        HUD.updateStatus(nation, false)
        Orders[nation]:enableReady(|...| self.resume(...))
    end
    for id, region in pairs(Map.regions) do if region.construction ~= nil then
        local owner, p = region:owner(), Promise()
        coroutine.resume(coroutine.create(|| self:deployUnits(region):next(p)))
        table.insert(deploy[owner], p:next(function (units) deploy[owner][id] = units end))
    end end
    for _, nation in turnOrder() do if #deploy[nation] > 0 then
        Orders[nation].UI.setAttribute('ready', 'interactable', false)
        Promise.all(deploy[nation]):next(function ()
            Orders[nation].UI.setAttribute('ready', 'interactable', true)
            for i = #deploy[nation], 1, -1 do deploy[nation][i] = nil end
    end) end end
    Phase.readyLoop(readied, next(readied) == nil, function (nation, ready) if ready then
        local ps = {}
        for id, units in pairs(deploy[nation]) do
            for i = #units, 1, -1 do if units[i] == nil then table.remove(units, i) end end
            while #units > 0 do
                local stack = {table.remove(units)}
                local pos, force = stack[1].getPosition():setAt('y', 0), Units[stack[1].getName()].force
                for i = #units, 1, -1 do if (units[i].getPosition():setAt('y', 0) - pos):magnitude() < 0.1 then
                    table.insert(stack, table.remove(units, i))
                end end
                table.insert(ps, Commands:getNew(
                    nation, force, pos:setAt('y', #stack * 0.21 + 7), stack[1].getRotation()
                ):next(|obj| Promise.condition(|| obj.resting, obj)):next(|command| command:form(nil, stack)):catch(function ()
                    for _, unit in ipairs(stack) do table.insert(units, unit) end
                    return Promise():reject('Failed to form new stack(s)')
                end))
        end end
        if #ps > 0 then Promise.all(ps):next(|| self.resume(nation, ready), || Orders[nation]:toggleReady(false)) end
    end end)
    self.resume = nil
end

function Refit:deployUnits(region)
    debug('Deploying units in ', region.id)
    while region.construction.units() > region:production() do
        debug('Over production capacity!')
        -- deal with this later
    end
    local nation, units = region:owner(), region.construction.removeAttachments()
    for _, unit in ipairs(units) do setGlow(unit, Color[nation]) end
    return stash(region.construction):next(|| units)
end
