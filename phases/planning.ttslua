function writeOrders(resume)
    updateTracker('Write orders and bids', '2 - Strategic Planning', 'orders')
    resetStatus()
    enableSave('planning')
    local ready = {}
    for _, nation in ipairs(state.turn_order) do
        state.objects.orders[nation].call('writeOrders', {getStressZone(nation) > 3, resume})
        ready[nation] = false
    end
    if state.scenario == 'global' and not state.pact_broken then
        state.objects.orders.japan.UI.setAttribute('pact', 'interactable', true)
        state.objects.orders.ussr.UI.setAttribute('pact', 'interactable', true)
    end
    playerReady = function (data)
        local all_ready = true
        for nation, value in pairs(ready) do if data[nation] ~= nil then
            updateStatus(nation, data[nation])
            ready[nation], all_ready = data[nation], all_ready and data[nation]
        else all_ready = all_ready and ready[nation] end end
        if all_ready then
            playerReady = nil
            disableSave()
            revealBids()
    end end
end

function validateCommand(params)
    local command = state.objects.commands[params[1]][params[2]]
    return command ~= nil and getRegion(command) ~= nil
end

function validateRegion(params) return Map.data.regions[params[1]] ~= nil end

function revealBids()
    updateTracker('Reveal bids')
    resetStatus()
    local bids, delay = {}, 0
    for nation, orders in pairs(state.objects.orders) do
        Wait.time(function ()
            bids[nation] = orders.call('revealBid')
            broadcastToAll(colorize(properName(nation), nation) .. ' bid ' .. colorize(bids[nation], 'oil') .. ' oil')
            updateStatus(nation, bids[nation], Colors.oil)
        end, delay)
        delay = delay + 0.5
    end
    Wait.time(|| setTurnOrder(bids), delay)
end

function setTurnOrder(bids)
    updateTracker('Establish turn order', nil, 'turn_order')
    state.new_turn_order = {}
    local order, spots = {}, {}
    for nation, bid in pairs(bids) do
        state.objects.turn_tokens[nation].setLock(true)
        table.insert(order, {bid = bid + math.random(), nation = nation})
    end
    table.sort(order, |a, b| a.bid < b.bid)
    for i = 1, #order do table.insert(spots, Map.obj.positionToWorld(Map.snaps[i].position)) end
    chooseTurns(order, spots)
end

function chooseTurns(order, spots)
    if #order == 0 then
        onObjectDrop = nil
        payBids()
    else
        local nation = table.remove(order).nation
        local token = state.objects.turn_tokens[nation]
        updateTurn(nation)
        token.setLock(false)
        setBlinker(token)
        onObjectDrop = function (_, obj) if obj.getGUID() == token.getGUID() then Wait.frames(function ()
            for i = 1, 7 do if spots[i] and obj.getPosition():setAt('y', spots[i].y) == spots[i] then
                stopBlinker(obj)
                state.new_turn_order[nation], state.new_turn_order[i] = i, nation
                spots[i] = nil
                updateStatus(nation, ({'①', '②', '③', '④', '⑤', '⑥', '⑦'})[i], Colors.white)
                chooseTurns(order, spots)
                break
        end end end, 15) end end
    end
end

function payBids()
    state.turn_order, state.new_turn_order = state.new_turn_order, nil
    for i, nation in ipairs(state.turn_order) do
        UI.setAttribute('tracker' .. i, 'image', nation)
        state.objects.orders[nation].call('payBid')
    end
    updateTurn()
    resetStatus()
    flipHotspots()
end
