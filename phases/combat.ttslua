-- Phase 4: Combat Operations

function combatOperations()
    updateTracker('Resolve hotspots', '4 - Combat Operations')
    resetStatus()
    state.combat = {landings = {}}
    state.combat.hotspots = checkHotspots()
    local highlights, turn = {}, 1
    updateTurn(state.turn_order[turn])
    onObjectHover = function (player, obj)
        if obj ~= nil and obj.getName() == 'hotspot' and not obj.getVar('busy') then
            local region, nation = getRegion(obj), state.turn_order[turn]
            removeHighlights(player, highlights)
            if region then
                local commands = getCommands(region)
                local combatants = hotspotCombatants(region, commands)
                obj.setTable('combatants', combatants)
                if combatants[nation] then for _, side in pairs(commands) do
                    for _, force in pairs(side) do for _, command in ipairs(force) do
                        command.setColorTint(colorTable(Colors[nation]))
                        table.insert(highlights[player], command)
        end end end end end else removeHighlights(player, highlights)
    end end
    onObjectRandomize = function (obj) if obj.getName() == 'hotspot' then
        obj.setVelocity({0, 0, 0})
        if obj.getVar('raid') then self.call('raid' .. getRegion(obj))
        elseif not obj.getVar('busy') then
            local region = getRegion(obj)
            if region then if not resolveHotspot(obj) then obj.setVar('busy', true) end
            else
                turn = turn % #state.turn_order + 1
                updateTurn(state.turn_order[turn])
    end end end end end
end

function removeHighlights(player, highlights)
    for _, command in ipairs(highlights[player] or {}) do command.setColorTint({1, 1, 1}) end
    highlights[player] = {}
end

function checkHotspots()
    debug('Checking all regions for hotspots')
    local hotspots, hotspot_bag = {}, getObjectFromGUID(GUIDs.Bags.hotspot)
    for _, obj in ipairs(getAllObjects()) do if obj.getName() == 'hotspot' then
        local region = getRegion(obj)
        if region then if not hotspots[region] then hotspots[region] = obj else returnPiece(obj) end end
    end end
    for region, commands in pairs(getAllCommands()) do
        if hotspotType(region, commands) then if not hotspots[region] then
            debug('Missing ', hotspotType(region, commands), ' hotspot in region ', region)
            local pos = Map.data.regions[region].centroid or Map.data.regions[region].circle.c
            hotspots[region] = hotspot_bag.takeObject({position = Map.obj.positionToWorld({pos[1], 0.8, pos[2]})})
        end elseif hotspots[region] then
            returnPiece(hotspots[region])
            hotspots[region] = nil
    end end
    return hotspots
end

function resolveHotspot(hotspot)
    local region = getRegion(hotspot)
    local hotspot_type = hotspotType(region)
    debug('Resolving ', hotspot_type, ' hotspot in region ', region)
    if hotspot_type == 'battle' then return resolveBattle(hotspot)
    elseif hotspot_type == 'garrison' then resolveGarrison(hotspot)
    elseif hotspot_type == 'raid' then resolveRaid(hotspot)
    elseif hotspot_type == 'bombing' then resolveBombing(hotspot)
    elseif hotspot_type == 'transports' then
        sinkTransports(region)
        removeCarrierFighters(region)
        returnPiece(hotspot)
    else returnPiece(hotspot) end
end

function hotspotType(region, commands)
    debug('Checking hotspot type for region ', region)
    commands = commands or getCommands(region)
    local is_sea = Map.data.regions[region].is_sea
    local force = is_sea and 'fleet' or 'army'
    local side, other, japan_only, ussr_only
    if commands.axis.air or commands.axis[force] then
        side, other = 'axis', 'allies'
        japan_only = nationOnly('japan', concatLists(commands.axis.air, commands.axis[force]))
        if japan_only then debug('Japan only in region ', region) end
    end
    if commands.allies.air or commands.allies[force] then
        ussr_only = nationOnly('ussr', concatLists(commands.allies.air, commands.allies[force]))
        if ussr_only then debug('USSR only in region ', region) end
        if side then if state.pact_broken or not (japan_only and ussr_only) then return 'battle' end
        else side, other = 'allies', 'axis' end
    end
    if side then if is_sea then
        local convoys = activeConvoys(region)
        if japan_only and ussr_only then
            if convoys.allies and not convoyOnly('ussr', convoys.allies)
                or convoys.axis and not convoyOnly('japan', convoys.axis) then return 'raid'
            elseif commands.allies.army and not nationOnly('ussr', commands.allies.army)
                or commands.axis.army and not nationOnly('japan', commands.axis.army) then return 'transports' end
        elseif convoys[other] and (state.pact_broken or
            not (japan_only and convoyOnly('ussr', convoys.allies)) and
            not (ussr_only and convoyOnly('japan', convoys.axis))) then return 'raid'
        elseif commands[other].army and (state.pact_broken or
            not (japan_only and nationOnly('ussr', commands.allies.army)) and
            not (ussr_only and nationOnly('japan', commands.axis.army))) then return 'transports' end
    else
        local owner = Alliance[getOwnership(region)]
        if japan_only and ussr_only then if owner == 'axis' then side, other = 'allies', 'axis' end end
        if owner == other then if commands[side].army then return 'garrison'
        else for _, command in ipairs(commands[side].air) do if command.getName():find('Bomber') then return 'bombing'
    end end end end end end
    return nil
end

function concatLists(...)
    local t = {}
    for _, list in pairs({...}) do if list then for _, item in ipairs(list) do table.insert(t, item) end end end
    return t
end

function nationOnly(nation, commands)
    for _, command in ipairs(commands) do if commandNation(command) ~= nation then return false end end
    return true
end

function convoyOnly(nation, convoys)
    local owner
    for _, cluster in ipairs(convoys) do for origin, _ in pairs(cluster) do
        if origin:find('-') then owner = getOwnership(origin:match('^(%w+)')) else owner = getOwnership(origin) end
        if owner ~= nation then return false end
    end end
    return true
end

function activeConvoys(region)
    local clusters, side = {}
    if not Map.data.regions[region].convoys then return clusters end
    for _, cluster in ipairs(Map.data.regions[region].convoys) do
        local temp = {}
        for origin, convoy in pairs(cluster) do
            if not origin:find('-') then
                side = Alliance[getOwnership(origin)]
                temp[side] = temp[side] or {}
                temp[side][origin] = convoy
            else
                local from_region, to_region = origin:match('(%w+)%-(%w+)')
                side = Alliance[getOwnership(from_region)]
                if side == Alliance[getOwnership(to_region)] then
                    temp[side] = temp[side] or {}
                    temp[side][origin] = convoy
        end end end
        for side, convoys in pairs(temp) do
            clusters[side] = clusters[side] or {}
            table.insert(clusters[side], temp[side])
    end end
    return clusters
end

function hotspotCombatants(region, commands)
    local combatants, owner = {}, getOwnership(region)
    if owner then combatants[owner] = true end
    for _, side in pairs(commands) do for _, force in pairs(side) do for _, command in ipairs(force) do
        combatants[commandNation(command)] = true
    end end end
    if hotspotType(region, commands) == 'raid' then
        local clusters, side = activeConvoys(region), (commands.axis.air or commands.axis.fleet) and 'allies' or 'axis'
        for _, cluster in ipairs(clusters[side]) do for origin, _ in ipairs(cluster) do
            combatants[getOwnership(origin:match('^%a%d+'))] = true
    end end end
    return combatants
end

-- -- Non-battle hotspots

-- -- -- Garrison defense
#include combat/garrison

-- -- -- Convoy raids
#include combat/raid

-- -- -- Bombing runs
#include combat/bomb

-- -- -- Sinking transports

function sinkTransports(hotspot)
    local region = getRegion(hotspot)
    local commands = getCommands(region)
    checkTransports(region, commands)
    debriefAirCommands(commands)
    returnPiece(hotspot)
end

-- -- -- Helpers

function removeUnit(stack, unit_type, callback)
    removeFromStack(stack, unit_type, function (unit)
        if isCommand(stack.getName()) then unit.setVar('nation', commandNation(stack))
        else unit.setVar('nation', getOwnership(getRegion(stack))) end
        MoraleBoard.call('stackCasualties', {unit.getGUID()})
    end, callback)
end

function lossLimit(region)
    local resources, p = Map.data.regions[region].resources, {}
    if resources then
        for resource, value in pairs(resources) do p[resource] = resources[resource] end
        if getCard(region).is_face_down then
            if p.oil then p.oil = p.oil - 1
            elseif p.iron then p.iron = p.iron - 1
            elseif p.osr then p.osr = p.osr - 1 end
    end end
    for resource, value in pairs(p) do if value == 0 then p[resource] = nil end end
    return p
end

-- -- Battles
#include combat/battle

-- -- Operation debriefing
#include combat/debrief
