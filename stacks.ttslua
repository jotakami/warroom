#include constants/colors

StackOrder = {
    'bomber', 'cfighter', 'fighter',
    'armor', 'artillery', 'infantry',
    'battleship', 'carrier', 'cruiser', 'submarine',
    bomber = 1, cfighter = 2, fighter = 3,
    armor = 4, artillery = 5, infantry = 6,
    battleship = 7, carrier = 8, cruiser = 9, submarine = 10
}

function buildStack(unit_counts, position, rotation, fast, callback)
    local types, units = {}, {}
    for _, type in ipairs(StackOrder) do if unit_counts[type] then
        for i = 1, unit_counts[type], 1 do table.insert(types, type) end
    end end
    stackUnits(types, units, position, rotation, fast, callback)
end

function stackUnits(types, units, position, rotation, fast, callback)
    local next = || stackUnits(types, units, position + vector(0, 0.21, 0), rotation, fast, callback)
    if #types == 0 then callback(units)
    else
        local unit_type = table.remove(types)
        getUnit(unit_type, {
            position = position, rotation = rotation,
            callback_function = function (obj)
                table.insert(units, obj)
                if not fast then next() end
        end})
        if fast then Wait.frames(|| next(), unit_type == types[1] and 1 or 10) end
    end
end

function getUnit(unit_type, params)
    if type(params) == 'table' then if UnitQueues[unit_type] then
        table.insert(UnitQueues[unit_type], params)
    else
        UnitQueues[unit_type] = {params}
        getUnit(unit_type, 1)
    end elseif params > #UnitQueues[unit_type] then UnitQueues[unit_type] = nil
    else
        getObjectFromGUID(GUIDs.Bags.Units[unit_type]).takeObject(UnitQueues[unit_type][params])
        Wait.frames(|| getUnit(unit_type, params + 1), 3)
    end
end

function sortUnits(units)
    table.sort(units, function (a, b)
        if StackOrder[a.getName()] == StackOrder[b.getName()] then return a.getPosition().y < b.getPosition().y
        else return StackOrder[a.getName()] > StackOrder[b.getName()] end
    end)
    return units
end

function getStack(command)
    local types, units = '', {}
    for _, unit_type in ipairs(StackOrder) do types = types .. unit_type .. ',' end
    for _, hit in ipairs(Physics.cast({
        origin = command.getPosition() + vector(0, 0.1, 0),
        direction = {0, -1, 0},
        max_distance = 2
    })) do if #hit.hit_object.getName() > 0 and types:find(hit.hit_object.getName()) then
        table.insert(units, hit.hit_object)
    end end
    table.sort(units, function (a, b) return a.getPosition().y < b.getPosition().y end)
    while #units > 8 do table.remove(units, 1) end
    return units
end

function checkStack(top, units)
    local pos, rot_y, order, align = units[1].getPosition(), units[1].getRotation().y, StackOrder[units[1].getName()]
    for _, unit in ipairs(units) do
        local rot = unit.getRotation()
        if rot.x > 180 then rot.x = 360 - rot.x end
        if rot.z > 180 then rot.z = 360 - rot.z end
        if (unit.getPosition() - pos):magnitude() > 0.02 then debug('Bad position, target=', pos, ', actual=', unit.getPosition(), ', delta=', (unit.getPosition() - pos):magnitude()) align = 'position'
        elseif (rot - vector(0, rot_y, 0)):magnitude() > 1 then debug('Bad rotation, target=', vector(0, rot_y, 0), ', actual=', rot, ', delta=', (rot - vector(0, rot_y, 0)):magnitude()) align = 'rotation'
        elseif StackOrder[unit.getName()] > order then debug('Bad order') align = 'order' end
        if align then return false end
        pos.y = unit.getPosition().y + 0.21
        order = StackOrder[unit.getName()]
    end
    return true
end

function alignStack(top, units, callback)
    debug('Realigning stack elements')
    local pos, rot_y
    for i, unit in ipairs(sortUnits(units)) do
        unit.setLock(true)
        if i == 1 then pos, rot = unit.getPosition(), vector(0, unit.getRotation().y, 0)
        else alignPosition(unit, pos) end
        alignRotation(unit, rot)
        pos = pos + vector(0, 0.21, 0)
    end
    top.setLock(true)
    alignPosition(top, pos)
    alignRotation(top, rot)
    return Wait.condition(function () Wait.frames(function ()
        for _, unit in ipairs(units) do unit.setLock(false) end
        top.setLock(false)
        Wait.frames(|| callback(top, units), 1)
    end, 1) end, function ()
        for _, unit in ipairs(units) do if unit.isSmoothMoving() then return false end end
        return not top.isSmoothMoving()
    end)
end

function alignPosition(unit, pos)
    if (unit.getPosition() - pos):magnitude() < 0.1 then unit.setPosition(pos)
    else unit.setPositionSmooth(pos, false, true) end
end

function alignRotation(unit, rot)
    if (unit.getRotation() - rot):magnitude() < 3 then unit.setRotation(rot)
    else unit.setRotationSmooth(rot, false, true) end
end

function formStack(command, player)
    local units, force, invalid = getStack(command), commandForce(command.getName())
    for _, obj in ipairs(Player[player].getSelectedObjects()) do
        local new = true
        if Colors[obj.getName():gsub('cfighter', 'no')] then
            for _, unit in ipairs(units) do if obj.getGUID() == unit.getGUID() then new = false break end end
            if new then table.insert(units, obj) end
    end end
    if #units > 0 and #units < 9 then for _, unit in ipairs(units) do
        if StackOrder[unit.getName()] < 4 then if force ~= 'air' then invalid = true break end
        elseif StackOrder[unit.getName()] < 7 then if force ~= 'army' then invalid = true break end
        elseif force ~= 'fleet' then invalid = true break end
    end else invalid = true end
    if not invalid then
        command.clearContextMenu()
        mergeStack(command, units)
    else debug('Could not form stack') end
end

function mergeStack(top, units)
    debug('Merging stack under ', top.getName())
    local count, desc = {}, ''
    local is_production = top.getName() == 'bomb_industry'
    local flag_nation = top.getName():match('(%a+) flag')
    if not checkStack(top, units) then return alignStack(top, units, mergeStack) end
    for _, unit in ipairs(units) do
        count[unit.getName()] = (count[unit.getName()] or 0) + 1
        top.addAttachment(unit)
    end
    for _, type in ipairs(StackOrder) do if count[type] then
        desc = desc .. ' ' .. count[type] .. ' ' .. colorize(proper(type), type) .. '\n'
        table.insert(count, count[type])
        table.insert(count, type)
    end end
    if is_production or flag_nation then top.tooltip = true end
    top.setName((
        is_production and 'Units under construction' or
        flag_nation and 'Defense force (' .. colorize(flag_nation, flag_nation:lower()) .. ')' or
        top.getName()
        ) .. '\n' .. desc:sub(1, -2)
    )
    top.clearContextMenu()
    if not flag_nation then
        top.addContextMenuItem('Break stack', || breakStack(top))
        if not is_production then top.addContextMenuItem('Combine stacks', |player| combineStacks(top, player)) end
    end
    top.setTable('units', count)
end

function breakStack(stack)
    local name, units = stack.getName(), stack.removeAttachments()
    stack.clearContextMenu()
    stack.addContextMenuItem('Form stack', |player| formStack(stack, player))
    stack.setVar('units', nil)
    if name:match('construction') then
        stack.setName('bomb_industry')
        stack.tooltip = false
    else
        local guid, nation = stack.getGUID(), name:match('%b[](%a+)%b[]')
        if name:match('Defense') then
            name, nation, guid = nation .. ' flag', 'neutral-' .. nation, nil
            stack.tooltip = false
        else name = name:match('^([^\n]+)\n') end
        stack.setName(name)
        for _, unit in ipairs(units) do Wait.condition(function ()
            unit.setVar('nation', nation:lower())
            unit.setVar('command', guid)
        end, || not unit.spawning) end
    end
    return units
end

function addToStack(unit, stack)
    local units = breakStack(stack)
    local spawning, index, order = #units, #units, StackOrder[unit.getName()]
    for i, unit in ipairs(units) do Wait.condition(function () spawning = spawning - 1 end, || not units[i].spawning) end
    Wait.condition(function ()
        local pos, rot = stack.getPosition(), stack.getRotation()
        stack.setLock(true)
        stack.setPositionSmooth(pos + vector(0, 0.21, 0), false, true)
        while index > 0 and StackOrder[units[index].getName()] < order do
            pos = units[index].getPosition()
            units[index].setLock(true)
            units[index].setPositionSmooth(pos + vector(0, 0.21, 0), false, true)
            index = index - 1
        end
        unit.setPositionSmooth(pos)
        unit.setRotationSmooth(rot)
        table.insert(units, index + 1, unit)
        Wait.condition(function ()
            stack.setLock(false)
            for i = index + 1, #units do units[i].setLock(false) end
            Wait.frames(|| mergeStack(stack, units), 3)
        end, || not unit.isSmoothMoving())
    end, || spawning == 0)
end

function removeFromStack(stack, unit_type, unit_callback, callback)
    local units = breakStack(stack)
    local spawning, index = #units
    for i, unit in ipairs(units) do Wait.condition(function () spawning = spawning - 1 end, || not units[i].spawning) end
    Wait.condition(function ()
        if #units == 1 and units[1].getName() == unit_type then
            returnPiece(stack)
            unit_callback(units[1])
            callback()
        else
            stack.setPositionSmooth(stack.getPosition() - units[#units].getPosition() + units[#units - 1].getPosition())
            for i = #units, 1, -1 do if units[i].getName() == unit_type or i == 1 then
                unit_callback(units[i])
                index = i
                break
            else units[i].setPositionSmooth(units[i - 1].getPosition()) end end
            table.remove(units, index)
            Wait.condition(function ()
                mergeStack(stack, units)
                callback()
            end, || not stack.isSmoothMoving())
    end end, || spawning == 0)
end

function combineStacks(command, player)
    local commands, name, i = Player[player].getSelectedObjects(), command.getName(), 1
    local nation, force, count = commandNation(command), commandForce(name), #command.getAttachments()
    while i <= #commands do
        if Colors[commands[i].getName():gsub('cfighter', 'no')] then count, i = count + 1, i + 1
        elseif not isCommand(commands[i].getName())
            or commandNation(commands[i]) ~= nation or commandForce(commands[i].getName()) ~= force
            or commands[i].getGUID() == command.getGUID() then table.remove(commands, i)
        else count, i = count + #commands[i].getAttachments(), i + 1 end
    end
    if #commands > 0 and count < 9 then
        local units = breakStack(command)
        for _, cmd in ipairs(commands) do
            if isCommand(cmd.getName()) then
                for _, unit in ipairs(breakStack(cmd)) do table.insert(units, unit) end
                Wait.frames(|| returnPiece(cmd), 1)
            else table.insert(units, cmd)
        end end
        Wait.frames(|| mergeStack(command, units), 1)
    else debug('Can\'t merge the selected units') end
end
