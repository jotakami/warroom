#include constants/colors

StackOrder = {
    'bomber', 'cfighter', 'fighter',
    'armor', 'artillery', 'infantry',
    'battleship', 'carrier', 'cruiser', 'submarine',
    bomber = 1, cfighter = 2, fighter = 3,
    armor = 4, artillery = 5, infantry = 6,
    battleship = 7, carrier = 8, cruiser = 9, submarine = 10
}

function buildStack(unit_counts, position, rotation, fast, callback)
    local types, units = {}, {}
    for _, type in ipairs(StackOrder) do if unit_counts[type] then
        for i = 1, unit_counts[type], 1 do table.insert(types, type) end
    end end
    stackUnits(types, units, position, rotation, fast, callback)
end

function stackUnits(types, units, position, rotation, fast, callback)
    local next = || stackUnits(types, units, position + vector(0, 0.21, 0), rotation, fast, callback)
    if #types == 0 then callback(units)
    else
        local unit_type = table.remove(types)
        getUnit(unit_type, {
            position = position,
            rotation = rotation,
            callback_function = function (obj)
                table.insert(units, obj)
                if not fast then next() end
            end
        })
        if fast then Wait.frames(|| next(), unit_type == types[1] and 1 or 10) end
    end
end

function getUnit(unit_type, params)
    if type(params) == 'table' then if UnitQueues[unit_type] then
        table.insert(UnitQueues[unit_type], params)
    else
        UnitQueues[unit_type] = {params}
        getUnit(unit_type, 1)
    end elseif params > #UnitQueues[unit_type] then UnitQueues[unit_type] = nil
    else
        getObjectFromGUID(GUIDs.Bags.Units[unit_type]).takeObject(UnitQueues[unit_type][params])
        Wait.frames(|| getUnit(unit_type, params + 1), 3)
    end
end

function sortUnits(units)
    table.sort(units, function (a, b)
        if StackOrder[a.getName()] == StackOrder[b.getName()] then return a.getPosition().y < b.getPosition().y
        else return StackOrder[a.getName()] > StackOrder[b.getName()] end
    end)
    return units
end

function getStack(command)
    command.clearContextMenu()
    local types, units = '', {}
    for _, unit_type in ipairs(StackOrder) do types = types .. unit_type .. ',' end
    for _, hit in ipairs(Physics.cast({
        origin = command.getPosition() + vector(0, 0.1, 0),
        direction = {0, -1, 0},
        max_distance = 2
    })) do if #hit.hit_object.getName() > 0 and types:find(hit.hit_object.getName()) then
        table.insert(units, hit.hit_object)
    end end
    table.sort(units, function (a, b) return a.getPosition().y < b.getPosition().y end)
    return units
end

function checkStack(top, units)
    local pos, rot_y, order, align = units[1].getPosition(), units[1].getRotation().y, StackOrder[units[1].getName()]
    for _, unit in ipairs(units) do
        local rot = unit.getRotation()
        if rot.x > 180 then rot.x = 360 - rot.x end
        if rot.z > 180 then rot.z = 360 - rot.z end
        if (unit.getPosition() - pos):magnitude() > 0.02 then debug('Bad position, target=', pos, ', actual=', unit.getPosition(), ', delta=', (unit.getPosition() - pos):magnitude()) align = 'position'
        elseif (rot - vector(0, rot_y, 0)):magnitude() > 1 then debug('Bad rotation, target=', vector(0, rot_y, 0), ', actual=', rot, ', delta=', (rot - vector(0, rot_y, 0)):magnitude()) align = 'rotation'
        elseif StackOrder[unit.getName()] > order then debug('Bad order') align = 'order' end
        if align then return false end
        pos.y = unit.getPosition().y + 0.21
        order = StackOrder[unit.getName()]
    end
    return true
end

function alignStack(top, units, callback)
    debug('Realigning stack elements')
    local pos, rot_y
    for i, unit in ipairs(sortUnits(units)) do
        unit.setLock(true)
        if i == 1 then pos, rot = unit.getPosition(), vector(0, unit.getRotation().y, 0)
        else alignPosition(unit, pos) end
        alignRotation(unit, rot)
        pos = pos + vector(0, 0.21, 0)
    end
    top.setLock(true)
    alignPosition(top, pos)
    alignRotation(top, rot)
    return Wait.condition(function () Wait.frames(function ()
        for _, unit in ipairs(units) do unit.setLock(false) end
        top.setLock(false)
        Wait.frames(|| callback(top, units), 1)
    end, 1) end, function ()
        for _, unit in ipairs(units) do if unit.isSmoothMoving() then return false end end
        return not top.isSmoothMoving()
    end)
end

function alignPosition(unit, pos)
    if (unit.getPosition() - pos):magnitude() < 0.1 then unit.setPosition(pos)
    else unit.setPositionSmooth(pos, false, true) end
end

function alignRotation(unit, rot)
    if (unit.getRotation() - rot):magnitude() < 3 then unit.setRotation(rot)
    else unit.setRotationSmooth(rot, false, true) end
end

function mergeStack(top, units)
    local count, desc, isProduction = {}, '', top.getName() == 'bomb_industry'
    if not checkStack(top, units) then return alignStack(top, units, mergeStack) end
    for _, unit in ipairs(units) do
        count[unit.getName()] = (count[unit.getName()] or 0) + 1
        top.addAttachment(unit)
    end
    for _, type in ipairs(StackOrder) do if count[type] then
        desc = desc .. ' ' .. count[type] .. ' ' .. colorize(proper(type), type) .. '\n'
        table.insert(count, count[type])
        table.insert(count, type)
    end end
    if isProduction then top.tooltip = true end
    top.setName((isProduction and 'Units under construction' or top.getName()) .. '\n' .. desc:sub(1, -2))
    top.clearContextMenu()
    top.addContextMenuItem('Break stack', || breakStack(top))
    top.setTable('units', count)
end

function breakStack(stack)
    local units = stack.removeAttachments()
    stack.clearContextMenu()
    stack.addContextMenuItem('Form stack', || mergeStack(stack, getStack(stack)))
    stack.setVar('units', nil)
    if stack.getName():match('construction') then
        stack.setName('bomb_industry')
        stack.tooltip = false
    else
        local name, guid = stack.getName():match('^([^\n]+)\n'), stack.getGUID()
        local nation = name:match('%b[](%a+)%b[]'):lower()
        stack.setName(name)
        for _, unit in ipairs(units) do Wait.condition(function ()
            unit.setVar('nation', nation)
            unit.setVar('command', guid)
        end, || not unit.spawning) end
    end
    return units
end

function addToStack(unit, stack)
    local units = breakStack(stack)
    local spawning, index, order = #units, #units, StackOrder[unit.getName()]
    for i, unit in ipairs(units) do Wait.condition(function () spawning = spawning - 1 end, || not units[i].spawning) end
    Wait.condition(function ()
        local pos, rot = stack.getPosition(), stack.getRotation()
        stack.setLock(true)
        stack.setPositionSmooth(pos + vector(0, 0.21, 0), false, true)
        while index > 0 and StackOrder[units[index].getName()] < order do
            pos = units[index].getPosition()
            units[index].setLock(true)
            units[index].setPositionSmooth(pos + vector(0, 0.21, 0), false, true)
            index = index - 1
        end
        unit.setPositionSmooth(pos)
        unit.setRotationSmooth(rot)
        table.insert(units, index + 1, unit)
        Wait.condition(function ()
            stack.setLock(false)
            for i = index + 1, #units do units[i].setLock(false) end
            Wait.frames(|| mergeStack(stack, units), 3)
        end, || not unit.isSmoothMoving())
    end, || spawning == 0)
end

function removeFromStack(stack, unit_type, unit_callback, callback)
    local units = breakStack(stack)
    local spawning, index = #units
    for i, unit in ipairs(units) do Wait.condition(function () spawning = spawning - 1 end, || not units[i].spawning) end
    Wait.condition(function ()
        if #units == 1 and units[1].getName() == unit_type then
            returnPiece(stack)
            unit_callback(units[1])
            callback()
        else
            stack.setPositionSmooth(stack.getPosition() - units[#units].getPosition() + units[#units - 1].getPosition())
            for i = #units, 1, -1 do if units[i].getName() == unit_type or i == 1 then
                unit_callback(units[i])
                index = i
                break
            else units[i].setPositionSmooth(units[i - 1].getPosition()) end end
            table.remove(units, index)
            Wait.condition(function ()
                mergeStack(stack, units)
                callback()
            end, || not stack.isSmoothMoving())
    end end, || spawning == 0)
end
