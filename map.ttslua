#include map-setup

function onLoad()
    state = {}
    prepareRegionData()
    loaded = true
end

function prepareRegionData()
    for region, data in pairs(MapData.Regions) do
        if data.points then
            data.box = {
                xmax = data.points[1][1], xmin = data.points[1][1],
                zmax = data.points[1][2], zmin = data.points[1][2]
            }
            data.centroid = {0, 0}
            local prev_point, sum, cross = data.points[#data.points], 0
            for _, point in ipairs(data.points) do
                if data.box.xmax < point[1] then data.box.xmax = point[1]
                elseif data.box.xmin > point[1] then data.box.xmin = point[1] end
                if data.box.zmax < point[2] then data.box.xmax = point[2]
                elseif data.box.zmin > point[2] then data.box.zmin = point[2] end
                cross = prev_point[1] * point[2] - point[1] * prev_point[2]
                data.centroid[1] = data.centroid[1] + (prev_point[1] + point[1]) * cross / 3
                data.centroid[2] = data.centroid[2] + (prev_point[2] + point[2]) * cross / 3
                sum = sum + cross
                prev_point = point
            end
            data.centroid[1] = data.centroid[1] / sum
            data.centroid[2] = data.centroid[2] / sum
        elseif data.circle then data.box = {
            xmax = data.circle.c[1] + data.circle.r,
            xmin = data.circle.c[1] - data.circle.r,
            zmax = data.circle.c[2] + data.circle.r,
            zmin = data.circle.c[2] - data.circle.r
        } end
        state[region] = {commands = {axis = {}, allies = {}}}
        local prefix = region:sub(1, 1)
        if Prefixes[prefix] then state[region].ownership = Prefixes[prefix] end
    end
end

-- Movement and Combat Operations

function hotspotType(region)
    if type(region) == 'table' then region = region[1] end
    local commands, side, other = state[region].commands
    if isSeaRegion(region) then
        if commands.axis.air or commands.axis.fleet then side, other = 'axis', 'allies' end
        if commands.allies.air or commands.allies.fleet then
            if side then return 'battle'
            else side, other = 'allies', 'axis' end
        end
        if not side then return nil
        elseif hasConvoy(region)[other] then return 'raid'
        elseif commands[other].army then return 'transports' end
    else
        if commands.axis.army or commands.axis.air then side, other = 'axis', 'allies' end
        if commands.allies.army or commands.allies.air then
            if side then return 'battle'
            else side, other = 'allies', 'axis' end
        end
        if not side then return nil
        elseif Alliance[state[region].ownership] == other then if commands[side].army then return 'garrison'
            else for _, command in ipairs(commands[side].air) do
                if command.getName():find('Bomber') then return 'bombing'
    end end end end end
    return nil
end

function hasConvoy(region)
    local t = {}
    if not MapData.Regions[region].convoys then return t end
    for i, convoy in ipairs(MapData.Regions[region].convoys) do for port_region, _ in pairs(convoy) do
        if not port_region:find('-') then t[Alliance[state[port_region].ownership]] = true
        else
            local from_region, to_region = port_region:match('(%w+)%-(%w+)')
            if Alliance[state[from_region].ownership] == Alliance[state[to_region].ownership] then
                t[Alliance[state[from_region].ownership]] = true
    end end end end
    return t
end

function getHotspot(region)
    if type(region) == 'table' then region = region[1] end
    if state[region].hotspot then return state[region].hotspot.getGUID() else return nil end
end

function getHotspots()
    local hotspots = {}
    for region, t in pairs(state) do if t.hotspot then
        table.insert(hotspots, {region = region, guid = t.hotspot.getGUID()})
    end end
    return hotspots
end

function getCommands(region)
    if type(region) == 'table' then region = region[1] end
    local guids = {}
    for side, forces in pairs(state[region].commands) do
        guids[side] = {}
        for force, commands in pairs(forces) do
            guids[side][force] = {}
            for _, command in ipairs(commands) do table.insert(guids[side][force], command.getGUID()) end
    end end
    return guids
end

function getFlagToken(region)
    if type(region) == 'table' then region = region[1] end
    return nil -- not yet implemented
end

function getOwner(region)
    if type(region) == 'table' then region = region[1] end
    return state[region].ownership
end

function getOriginalOwner(region)
    if type(region) == 'table' then region = region[1] end
    return MapData.Regions[region].original_owner or Prefixes[region:sub(1, 1)]
end

function getSV(region)
    if type(region) == 'table' then region = region[1] end
    return MapData.Regions[region].sv or 0
end

function getPorts(region)
    if type(region) == 'table' then region = region[1] end
    local ports = {}
    for _, link in ipairs(MapData.Regions[region].adjacent) do if link:sub(-1) == '$' then table.insert(ports, link:sub(1, -2)) end end
    return ports
end

-- Collision Checks

function onCollisionEnter(collision_info)
    if not loaded then return end
    local obj = collision_info.collision_object
    local pos, name = self.positionToLocal(obj.getPosition()), obj.getName()
    if pos == last_pos then return nil
    else
        if reset then Wait.stop(reset) end
        last_pos = pos
        reset = Wait.frames(function () last_pos = nil end, 1)
    end
    local region = findRegion({pos.x, pos.z})
    if region then
        obj.setVar('region', region)
        if name == 'hotspot' then state[region].hotspot = obj
        elseif name == 'cfighter' then addCommand(state[region].commands, obj)
        elseif isCommand(name) then
            obj.setDescription('In region ' .. prettyName(region))
            obj.setRotationSmooth({0, rotationToCenter(pos), 0}, true, true)
            addCommand(state[region].commands, obj)
        end
        print('coords: ', pos.x, ' ', pos.z, ', region: ', region)
    else print('coords: ', pos.x, ' ', pos.z) end
end

function onCollisionExit(collision_info)
    if not loaded then return end
    local obj = collision_info.collision_object
    local region, name = obj.getVar('region'), obj.getName()
    if region then
        obj.setVar('region', nil)
        if name == 'hotspot' and state[region].hotspot.getGUID() == obj.getGUID() then state[region].hotspot = nil
        elseif isCommand(name) or name == 'cfighter' then
            obj.setDescription('')
            removeCommand(state[region].commands, obj)
        end
    end
end

function isCommand(name)
    local force = name:match('^%b[]%a+%b[]%s%d+%a%a%s(%a+)')
    return force == 'Army' or force == 'Air' or force == 'Fleet'
end

function commandNation(name, command)
    if name == 'cfighter' then return command.getVar('nation')
    else return name:match('^%b[](%a+)'):lower() end
end

function commandType(name)
    if name == 'cfighter' then return 'air'
    else return name:match('%d+%a%a%s(%a+)'):lower() end
end

function addCommand(t, command)
    local name = command.getName()
    local alliance, command_type = Alliance[commandNation(name, command)], commandType(name)
    if not t[alliance][command_type] then t[alliance][command_type] = {} end
    table.insert(t[alliance][command_type], command)
end

function removeCommand(t, command)
    local name = command.getName()
    local alliance, command_type = Alliance[commandNation(name, command)], commandType(name)
    local commands = t[alliance][command_type]
    if commands then
        for i = #commands, 1, -1 do if commands[i].getGUID() == command.getGUID() then table.remove(commands, i) end end
        if #commands == 0 then t[alliance][command_type] = nil end
    end
end

function commandRemoved(data)
    removeCommand(state[data[2]].commands, getObjectFromGUID(data[1]))
end

function isSeaRegion(region)
    if type(region) == 'table' then region = region[1] end
    return region:find('a') or region:find('i') or region:find('m') or region:find('p')
end

function getRegionName(region)
    if type(region) == 'table' then region = region[1] end
    return MapData.Regions[region].name
end

function prettyName(region)
    if type(region) == 'table' then region = region[1] end
    local str = region:upper()
    if str:match('[AIMP]') then return str:sub(1, 1) .. '-' .. str:sub(2)
    else return str .. ' - ' .. MapData.Regions[region].name end
end

function findRegion(point)
    local regions = {}
    for region, data in pairs(MapData.Regions) do
        if data.box.xmax > point[1] and data.box.xmin < point[1] and data.box.zmax > point[2] and data.box.zmin < point[2] then
            if data.islands then table.insert(regions, region) else table.insert(regions, 1, region) end
        end
    end
    if #regions == 1 then return regions[1]
    else for _, region in ipairs(regions) do
        if MapData.Regions[region].circle then
            if distance(point, MapData.Regions[region].circle.c) < MapData.Regions[region].circle.r then
                return region
            end
        elseif inside2d(point, MapData.Regions[region].points) then
            return region
        end
    end end
end

function centroid(region)
    if type(region) == 'table' then region = region[1] end
    if MapData.Regions[region].circle then return MapData.Regions[region].circle.c
    else return MapData.Regions[region].centroid end
end

function distance(p1, p2)
    return ((p2[1] - p1[1]) ^ 2 + (p2[2] - p1[2]) ^ 2) ^ 0.5
end

function inside2d(point, polygon)
    local v1, inside = polygon[#polygon], false
    for _, v2 in ipairs(polygon) do
        if (point[1] > v1[1]) != (point[1] > v2[1]) and (point[1] - v1[1]) * signed_area(point, v1, v2) > 0 then
            inside = not inside
        end
        v1 = v2
    end
    return inside
end

function signed_area(a, b, c)
    return a[1] * (b[2] - c[2]) - a[2] * (b[1] - c[1]) + b[1] * c[2] - b[2] * c[1]
end

function rotationToCenter(point)
    return (math.atan2(point.x - MapData.center.x, point.z - MapData.center.z) / math.pi + 1) * 180
end

Alliance = {
    china = 'allies',
    uk = 'allies',
    usa = 'allies',
    ussr = 'allies',
    germany = 'axis',
    italy = 'axis',
    japan = 'axis'
}

Prefixes = {
    b = 'uk',
    c = 'china',
    g = 'germany',
    i = 'italy',
    j = 'japan',
    n = 'neutral',
    r = 'ussr',
    u = 'usa'
}
