function cardRegion(card) return card.getName():lower():match('^%a%d+') end

function sortCards(cards, prefix)
    table.sort(cards, |a, b| compareCards(a, b, prefix))
end

function compareCards(a, b, prefix)
    local ap, an = a.getName():lower():match('^(%a)(%d+)')
    local bp, bn = b.getName():lower():match('^(%a)(%d+)')
    an, bn = an + 0, bn + 0
    if ap == bp then return an < bn
    elseif ap == prefix then return true
    elseif bp == prefix then return false
    else return ap < bp end
end

function getCard(id, nation)
    for n, guids in pairs(GUIDs.Nations) do if not nation or nation == n then
        for _, card in ipairs(getObjectFromGUID(guids.card_zone).getObjects()) do
            if cardRegion(card) == id then return card end
    end end end
end

function takeCard(id, nation, callback)
    local card_zone = getObjectFromGUID(GUIDs.Nations[nation].card_zone)
    local cards, moves, index, locked = card_zone.getObjects(), {}
    sortCards(cards, regionPrefix(nation))
    for i, card in ipairs(cards) do if card.getLock() then locked = true else
        if cardRegion(card) == id then index = i end
        if index then table.insert(moves, card.getPosition()) end
    end end
    if locked then Wait.condition(|| Wait.frames(|| takeCard(id, nation, callback), 3), function ()
        for _, card in ipairs(card_zone.getObjects()) do if card.getLock() then return false end end
        return true
    end) elseif index then
        debug('Taking ', id, ' card from ', nation)
        cards[index].setLock(true)
        cards[index].setPositionSmooth(cards[index].getPosition() + vector(0, 5, 0))
        cards[index].setRotationSmooth({0, cards[index].getRotation().y, 0})
        local start = index < #cards and math.floor((index - 1) / 12) * 12 + 1 or index
        for i = start, #cards do if i ~= index then
            cards[i].setLock(true)
            if i > index then
                cards[i].setPositionSmooth(moves[i - index])
                if i % 12 == 0 and i < #cards then cards[i].rotate({0.91, 0, 0})
                elseif i % 12 == 1 and i < #cards then cards[i].rotate({-0.91, 0, 0}) end
            else cards[i].translate({0, 0.1, 0}) end
        end end
        if start < index then Wait.condition(function ()
            for i = start, #cards do if i ~= index then cards[i].setLock(false) end end
        end, function ()
            for i = start, #cards do if i ~= index and cards[i].isSmoothMoving() then return false end end
            return true
        end) end
        Wait.condition(|| callback(cards[index]), || not cards[index].isSmoothMoving())
    else debug('Couldn\'t take ', id, ' card from ', nation) end
end

function giveCard(new_card, nation)
    debug('Giving ', new_card.getName(), ' card to ', nation)
    local card_zone = getObjectFromGUID(GUIDs.Nations[nation].card_zone)
    local cards, moves, locked = card_zone.getObjects(), {}
    local index = #cards + 1
    sortCards(cards, regionPrefix(nation))
    for i, card in ipairs(cards) do if card.getLock() then locked = true else
        if i < index and compareCards(new_card, card, regionPrefix(nation)) then index = i end
        if i >= index then table.insert(moves, card.getPosition()) end
    end end
    if not locked then
        local rack = getObjectFromGUID(GUIDs.Nations[nation].territories[math.floor(#cards / 12) + 1])
        table.insert(moves, rack.positionToWorld(rack.getSnapPoints()[#cards % 12 + 1].position))
        table.insert(cards, index, new_card)
        local start = math.floor((index - 1) / 12) * 12 + 1
        for i = start, #cards do
            cards[i].setLock(true)
            if i >= index then
                cards[i].setPositionSmooth(moves[i - index + 1])
                if i == index then cards[i].setRotationSmooth({i % 12 > 0 and i < #cards and 0.91 or 0, rack.getRotation().y, 0})
                elseif i % 12 == 1 and i < #cards then cards[i].rotate({0.91, 0, 0})
                elseif i % 12 == 0 and i > index and i < #cards then cards[i].rotate({-0.91, 0, 0}) end
            else cards[i].translate({0, 0.1, 0}) end
        end
        Wait.condition(function () for i = start, #cards do cards[i].setLock(false) end end, function ()
            for i = start, #cards do if cards[i].isSmoothMoving() then return false end end
            return true
        end)
    else Wait.condition(|| Wait.frames(|| giveCard(new_card, nation), 3), function ()
        for _, card in ipairs(card_zone.getObjects()) do if card.getLock() then return false end end
        return true
    end) end
end
