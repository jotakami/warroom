#include constants/battle
#include constants/nations
#include xml/battle
#include stacks
#include dice
#include debug

--- Save and load ---

function onLoad()
    state = {}
    self.UI.setXml(XML)
    loadZones()
    local GUIDs = Global.getTable('GUIDs')
    HotspotBag, ArrowBag = getObjectFromGUID(GUIDs.Bags.hotspot), getObjectFromGUID(GUIDs.Bags.arrow)
    DieBags = {getObjectFromGUID(DieGUIDs[1]), getObjectFromGUID(DieGUIDs[2])}
    MoraleBoard = getObjectFromGUID(GUIDs.MoraleBoard)
    self.addContextMenuItem('Reset script', || resetState())
end

--- Battle setup ---

function flipBoard()
    local sign = self.is_face_down and -1 or 1
    self.setPositionSmooth(self.getPosition() + vector(0, 0.2, 0) * sign)
    self.setRotationSmooth(self.getRotation() + vector(0, 0, 180) * sign)
end

function setupCombat(data)
    local setup = data[1]
    state.hotspot = data[2]
    local region = state.hotspot.getVar('region')
    debug('setup: ', setup, ', hotspot: ', state.hotspot.getGUID(), ', region: ', region)
    self.UI.setValue(setup .. '-region', region:gsub('([aimp])', '%1-'):upper())
    self.UI.setAttribute(setup .. '-region', 'color', '#' .. (Colors[Prefixes[region:sub(1, 1)] or 'sea']))
    if (setup == 'land') == self.is_face_down then
        flipBoard()
        Wait.condition(function ()
            adjustZones()
            adjustSnapPoints()
        end, || not self.isSmoothMoving())
    end
end

function isReady() return not state.hotspot end

function setStances()
    local mode, unit_types, ready = combatMode(), {}, {}
    self.UI.setAttribute(mode .. '-status-panel', 'active', true)
    self.UI.setValue(mode .. '-status', 'Set stances')
    state.dice = {}
    for side, zones in pairs(Zones.units[mode]) do
        self.UI.setAttribute(mode .. '-' .. side .. '-roll-frame', 'active', false)
        self.UI.setAttribute(mode .. '-' .. side .. '-confirm-panel', 'active', true)
        self.UI.setAttributes(mode .. '-' .. side .. '-confirm', {
            text = 'Ready?',
            onClick = 'stancesReady(' .. side .. ')',
            interactable = true
        })
        state.dice[side] = {}
        for stage, _ in pairs(CombatParams[mode].stages) do state.dice[side][stage] = 0 end
        unit_types[side] = 0
        for unit, stances in pairs(zones) do
            local has_unit = false
            for stance, zone in pairs(stances) do
                local count = countUnits(zone, unit)
                if count > 0 then
                    has_unit = true
                    addDice(state.dice[side], CombatParams[mode].units[unit][stance].dice, count)
                    updateDiceText(side)
            end end
            if has_unit and unit ~= 'fighter' and unit ~= 'bomber' then unit_types[side] = unit_types[side] + 1 end
    end end
    onObjectEnterScriptingZone = |zone, obj| updateUnitDice(zone, obj, 1)
    onObjectLeaveScriptingZone = |zone, obj| updateUnitDice(zone, obj, -1)
    stancesReady = function (_, side)
        ready[side] = true
        self.UI.setAttributes(mode .. '-' .. side .. '-confirm', {text = 'Ready', interactable = false})
        if ready.axis and ready.allies then
            stancesReady = nil
            setupStage('air')
    end end
    setForceAdvantage(unit_types.axis, unit_types.allies)
end

function getDropPoints()
    local mode, points = combatMode(), {x = {}, z = {}}
    points.y = 0.1 * (mode == 'land' and 2 or 0)
    points.z.command = ZoneParams[mode].commands
    for _, columns in pairs(ZoneParams[mode].sides) do for nation, x in pairs(columns.nations) do points.x[nation] = x end end
    for unit, stances in pairs(ZoneParams[mode].units) do
        points.z[unit] = stances.antiair or stances.air or stances.ground or stances.surface or stances.escort or stances.defensive or stances.dive
    end
    return points
end

--- Tracking dice totals ---

function updateUnitDice(zone, obj, count)
    local info = Zones.units.byGUID[combatMode()][zone.getGUID()]
    if info and obj.getName():find(info.unit) then
        addDice(state.dice[info.side], CombatParams[combatMode()].units[info.unit][info.stance].dice, count)
        updateDiceText(info.side)
    end
end

function addDice(totals, per_unit, units)
    for stage, n in pairs(totals) do totals[stage] = n + (per_unit[stage] or 0) * units end
end

function countUnits(zone, unit)
    local count = 0
    for _, obj in ipairs(zone.getObjects()) do if obj.getName():find(unit) then count = count + 1 end end
    return count
end

function countStageUnits(side, stage)
    local total, mode = 0, combatMode()
    for _, unit in pairs(CombatParams[mode].stages[stage]) do
        for stance, zone in pairs(Zones.units[mode][side][unit]) do total = total + countUnits(zone, unit) end
    end
    return total
end

function updateDiceText(side)
    for stage, value in pairs(state.dice[side]) do
        local id = combatMode() .. '-' .. side .. '-' .. stage
        if value > 0 then
            self.UI.show(id)
            self.UI.setValue(id .. '-dice', math.min(value, 30))
        else self.UI.hide(id) end
    end
end

--- Force and Port Advantage ---

function setForceAdvantage(axis, allies)
    local adv, mode = axis - allies, combatMode()
    if adv ~= 0 then
        local mode_sign = mode == 'land' and 1 or -1
        local side = math.abs(adv) / adv * mode_sign
        ArrowBag.takeObject({
            position = self.positionToWorld({0.12 * side, 2 * mode_sign, ZoneParams[combatMode()].commands - (mode == 'sea' and 0.06 or 0)}),
            rotation = self.getRotation() + vector(90 + 90 * side, 90 * mode_sign, 0),
            smooth = false
        })
    end
end

function checkForceAdvantage()
    for _, obj in ipairs(Zones.commands.getObjects()) do
        if obj.getName() == 'arrow' and (combatMode() == 'land' or self.positionToLocal(obj.getPosition()).z < ZoneParams.sea.commands) then
            if obj.is_face_down then return 'axis' else return 'allies' end
    end end
    return nil
end

function setPortAdvantage(side)
    if type(side) == 'table' then side = side[1] end
    local sign = side == 'axis' and -1 or 1
    if combatMode() == 'sea' then ArrowBag.takeObject({
        position = self.positionToWorld({0.12 * sign, -2, ZoneParams.sea.commands + 0.06}),
        rotation = self.getRotation() + vector(90 + 90 * sign, -90, 0),
        smooth = false
    }) end
    if countStageUnits(side, 'surface') > 0 then
        state.dice[side].surface = state.dice[side].surface + 2
        updateDiceText(side)
    end
end

function checkPortAdvantage(side)
    if combatMode() == 'sea' then for _, obj in ipairs(Zones.commands.getObjects()) do
        if obj.getName() == 'arrow' and self.positionToLocal(obj.getPosition()).z > ZoneParams.sea.commands then
            if (side == 'axis') == obj.is_face_down then return true end
    end end end
    return false
end

--- Combat stage setup ---

function setupStage(stage)
    debug('Setting up ', stage, ' stage')
    local mode, rollers = combatMode()
    self.UI.setValue(mode .. '-status', stage:sub(1,1):upper() .. stage:sub(2) .. ' stage')
    for side, _ in pairs(state.dice) do
        self.UI.hide(mode .. '-' .. side .. '-' .. stage)
        if state.dice[side][stage] > 0 and (stage == 'bomb' or countStageUnits(other(side), stage) > 0) then
            if rollers then rollers = 'both' else rollers = side end
            setHotspotCounters(side, stage, math.min(state.dice[side][stage], 30))
        end
        state.dice[side][stage] = 0
    end
    if rollers == 'both' then
        startRound = function (_, _, id)
            local side = id:match('%-(%a+)%-')
            startRound = nil
            rollRound(stage, side, true)
        end
        for side, _ in pairs(state.dice) do
            self.UI.show(mode .. '-' .. side .. '-confirm-panel')
            self.UI.setAttributes(mode .. '-' .. side .. '-confirm', {
                text = 'Roll', interactable = true, onClick = 'startRound'
            })
        end
    elseif rollers then
        Wait.frames(|| rollRound(stage, rollers, nil, stage == 'bomb' and getBombTargets(rollers)), 20)
    else advanceStage(stage) end
end

function advanceStage(stage)
    if stage == 'air' then
        onObjectEnterScriptingZone, onObjectLeaveScriptingZone = nil, nil
        if combatMode() == 'land' then setupStage('bomb') else setupStage('surface') end
    elseif stage == 'bomb' then
        self.UI.hide('axis-bomb-targets')
        self.UI.hide('allies-bomb-targets')
        setupStage('ground')
    else makeRepairs() end
end

function setHotspotCounters(side, stage, num)
    local mode = combatMode()
    local y_sign = mode == 'land' and 1 or -1
    local y_inc, x_sign = 0.71 * y_sign, (side == 'axis' and 1 or -1) * y_sign
    local x, y, z_min = 1.5 * x_sign, 0.1 * (1 + y_sign) + y_inc / 2, ZoneParams.land.units.bomber.strategic
    local start = self.positionToWorld({(mode == 'land' and 0.95 or 0.89) * x_sign, y, ZoneParams[mode].commands})
    if stage == 'bomb' then while num > 0 do
        num = num - 4
        setHotspotCounter(start, self.positionToWorld({x, y, ZoneParams.land.units.armor.offensive}))
        y = y + y_inc
    end else
        setHotspotCounter(start, self.positionToWorld({x, y, (30 - num) % 10 * 0.173 + z_min}))
        if num % 10 == 0 then y = y + y_inc end
        if num > 10 then setHotspotCounter(start, self.positionToWorld({x, y, z_min})) end
        y = y + y_inc
        if num > 20 then setHotspotCounter(start, self.positionToWorld({x, y, z_min})) end
    end
end

function setHotspotCounter(start, moveTo) HotspotBag.takeObject({
    position = start, smooth = false,
    callback_function = |obj| Wait.condition(|| obj.setPositionSmooth(moveTo, false, true), || not obj.spawning)
}) end

function getBombTargets(side)
    local targets, colors = {}, Global.call('getBombTargets', {state.hotspot.getVar('region')})
    for _, target in ipairs(BombOrder) do if colors[target[1]][target[2]] then
        table.insert(targets, {color = target[1], target = target[2], qty = colors[target[1]][target[2]]})
    end end
    self.UI.show(side .. '-bomb-targets')
    for i = 1, 8 do if targets[i] then
        self.UI.setAttributes(side .. '-target' .. i, {
            text = targets[i].qty, textColor = targets[i].color == 'white' and 'red' or 'white',
            image = targets[i].target, active = true, interactable = false
        })
    else self.UI.hide(side .. '-target' .. i) end end
    return targets
end

--- Roll dice ---

function rollRound(stage, side, switch, targets)
    local mode = combatMode()
    local num, more = getRollCounter(side)
    local callback = function ()
        local ready, wait_fun = mode ~= 'sea'
        if not ready then
            for _, unit in ipairs(Zones.units[mode][other(side)].submarine.dive.getObjects()) do
                if getColumn(unit) == 'damaged' then
                    unit.setVar('nation', nil)
                    unit.setPositionSmooth(self.positionToWorld({other(side) == 'axis' and -1.275 or 1.27, -0.63, -0.365}))
                    unit.setRotationSmooth({0, self.getRotation().y, 0})
                    wait_fun = Wait.condition(function () ready = true end, || not unit.isSmoothMoving())
                    break
            end end
            if not wait_fun then ready = true end
        end
        Wait.condition(function ()
            if switch or more then rollRound(stage, switch and other(side) or side, switch and more, targets)
            else advanceStage(stage)
        end end, || ready)
    end
    if stage ~= 'bomb' and countStageUnits(other(side), stage) == 0 then Wait.frames(|| callback(), 12)
    else
        setStatusRolling(side)
        rollDice(num, function (results)
            local a, b = 1, #results.objs
            while a < b do results.objs[a], results.objs[b], a, b = results.objs[b], results.objs[a], a + 1, b - 1 end
            if stage == 'bomb' then assignBombs(side, results.objs, targets, callback)
            else assignHits(side, stage, results.objs, callback) end
        end)
    end
end

function setStatusRolling(side)
    local id = combatMode() .. '-' .. side .. '-confirm'
    self.UI.hide(id:gsub(side, other(side)) .. '-panel')
    self.UI.show(id .. '-panel')
    self.UI.setAttributes(id, {text = 'Rolling', interactable = false})
end

function getRollCounter(side)
    local mode, counter, more = combatMode()
    local y_sign = mode == 'land' and 1 or -1
    local x_sign = (side == 'axis' and 1 or -1) * y_sign
    local origin = self.positionToWorld({1.5 * x_sign, 0.1 + 0.455 * y_sign, -1.05})
    for _, obj in ipairs(Physics.cast({
        origin = origin,
        direction = self.getTransformForward(),
        max_distance = 15
    })) do if not counter then counter = obj.hit_object
        else
            more = true
            if obj.hit_object.getPosition():distance(origin) < counter.getPosition():distance(origin) then
                counter = obj.hit_object
    end end end
    if not more then for _, _ in ipairs(Physics.cast({
        origin = counter.getPosition() + vector(0, 0.2, 0),
        direction = {0, 1, 0},
        max_distance = 5
    })) do more = true end end
    local num = math.floor((16.3 - counter.getPosition():distance(origin)) / 1.47 + 0.1)
    counter.destruct()
    return num, more
end

function rollClick(_, _, id)
    local side, num = id:match('%a+%-roll%-(%a+)%-(%d+)$')
    broadcastToAll(colorize(proper(side), side) .. '[-] rolling ' .. num .. ' dice')
    rollDice(num + 0)
end

function rollDice(num, callback)
    local roll, i = {objs = {}}, 0
    if not callback then callback = || nil end
    Wait.time(function ()
        local bag, other = DieBags[i % 2 + 1], DieBags[(i + 1) % 2 + 1]
        local force = vector(
            bag.positionToLocal(other.getPosition()).x * (math.random() / 2.5 + 0.15),
            math.random() * 5 + 3,
            (math.random() - 0.5) * 5
        )
        rollDie(i + 1, bag, force, roll)
        i = i + 1
    end, 0.15, num)
    Wait.condition(function ()
        arrangeResults(roll)
        Wait.condition(|| callback(roll), || not roll.objs[num].isSmoothMoving())
    end, || roll.objs[num] ~= nil)
end

function rollDie(index, bag, force, results) bag.takeObject({
    position = bag.getPosition() + vector(0, 3, 0),
    rotation = vector(math.random(360), 0, math.random(360)),
    smooth = false,
    callback_function = function (obj)
        obj.use_gravity = false
        Wait.time(function ()
            obj.use_gravity = true
            obj.addForce(force)
            obj.addTorque({math.random() * 2, math.random() * 2, math.random() * 2})
            Wait.time(function () results.objs[index] = obj end, 3)
        end, 0.2)
    end
}) end

function arrangeResults(roll)
    local left, right = DieBags[1].getPosition() + vector(0, 0.5, 0), DieBags[2].getPosition() + vector(0, 0.5, 0)
    table.sort(roll.objs, |a, b| DiceOrder[getDieColor(a)] < DiceOrder[getDieColor(b)])
    roll.result = {}
    local msg = ''
    for i, die in ipairs(roll.objs) do
        roll.result[getDieColor(die)] = (roll.result[getDieColor(die)] or 0) + 1
        die.setPositionSmooth(left:lerp(right, 0.47 - #roll.objs * 0.03 + i * 0.06))
        die.setRotationSmooth(die.getRotationValues()[die.getValue()].rotation)
    end
    for color, num in pairs(roll.result) do msg = msg .. '[' .. Colors[color] .. ']' .. num .. '[-], ' end
    broadcastToAll('Roll result: ' .. msg:sub(1, -6))
end

--- Assign hits ---

function assignBombs(side, dice, targets, callback)
    if #dice == 0 then
        for i, target in ipairs(targets) do toggleBombButton(side, i, false, target.color == 'white') end
        callback()
    else
        local die = table.remove(dice)
        local color, waiting = getDieColor(die)
        for i, target in ipairs(targets) do if (color == 'black' or color == target.color) and target.qty > 0 then
            waiting = true
            toggleBombButton(side, i, true, target.color == 'white')
        else toggleBombButton(side, i, false, target.color == 'white') end end
        if waiting then
            setBlinker(die)
            assignBomb = function (_, _, id)
                assignBomb = nil
                local index = id:match('%d+') + 0
                Global.call('bombHit', {
                    state.hotspot.getVar('region'),
                    targets[index].target,
                    state.hotspot.getPosition() + vector(0, 1, 0)
                })
                stopBlinker(die)
                die.destruct()
                targets[index].qty = targets[index].qty - 1
                self.UI.setAttribute(side .. '-target' .. index, 'text', targets[index].qty)
                assignBombs(side, dice, targets, callback)
            end
        else
            die.destruct()
            assignBombs(side, dice, targets, callback)
    end end
end

function toggleBombButton(side, index, enable, bomb)
    self.UI.setAttributes(side .. '-target' .. index, {textColor = bomb and 'red' or 'white', interactable = enable})
end

function assignHits(side, stage, dice, callback)
    local fd, skips, waiting = checkForceAdvantage() == other(side)
    if stage == 'air' then skips = 'yellow,blue'
    elseif stage == 'ground' then skips = 'red'
    else skips = '' end
    if stage ~= 'air' and fd then skips = 'black,white,' .. skips end
    while #dice > 0 and not waiting do
        local die = table.remove(dice)
        local color = getDieColor(die)
        if skips:match(color) then die.destruct()
        else
            local targets = getTargets(side, stage, color)
            if #targets == 0 then
                die.destruct()
                skips = color .. ',' .. skips
            else
                waiting = true
                local hit_callback = || assignHits(side, stage, dice, callback)
                if #targets > 1 then createHitButtons(die, targets, hit_callback)
                else assignHit(targets[1], die, hit_callback) end
    end end end
    if #dice == 0 and not waiting then callback() end
end

function getTargets(side, stage, color)
    local mode, units, targets = combatMode(), {}, {}
    local escort, escort_targeted
    if color == 'black' or color == 'white' then
        for _, unit in pairs(CombatParams[mode].stages[stage]) do table.insert(units, unit) end
    else table.insert(units, CombatParams[mode].stages[stage][color]) end
    for _, unit in ipairs(units) do
        for stance, zone in pairs(Zones.units[combatMode()][other(side)][unit]) do
            for _, t in ipairs(getTarget(zone, unit, color == 'white')) do
                table.insert(targets, t)
                if unit == 'carrier' or unit == 'battleship' then escort = true end
                if stance == 'escort' then escort_targeted = true end
    end end end
    if escort and not escort_targeted then
        for _, t in ipairs(getTarget(Zones.units[combatMode()][other(side)].cruiser.escort, 'cruiser')) do table.insert(targets, t) end
    end
    return targets
end

function getTarget(zone, unit, white_hit)
    local units, targets = {}, {}
    for _, obj in ipairs(zone.getObjects()) do if obj.getName():match(unit) then
        local align = getColumn(obj)
        if not units[align] or isAbove(obj, units[align]) then units[align] = obj end
    end end
    if units['damaged'] and (unit ~= 'submarine' or not white_hit) then table.insert(targets, units['damaged'])
    elseif not white_hit then
        if units['sustained'] then table.insert(targets, units['sustained'])
        else for nation, obj in pairs(units) do table.insert(targets, obj) end end
    end
    return targets
end

function createHitButtons(die, targets, callback)
    setBlinker(die)
    for _, target in ipairs(targets) do
        setBlinker(target)
        createHitButton(target)
    end
    clickHit = function (_, guid)
        stopBlinker(die)
        for _, target in ipairs(targets) do
            stopBlinker(target)
            target.UI.setXml('')
        end
        assignHit(getObjectFromGUID(guid), die, || callback())
        clickHit = nil
    end
end

function createHitButton(obj) obj.UI.setXmlTable({{tag = 'Button', attributes = {
    position = '0 0 ' .. (obj.is_face_down and '2' or '-29'),
    rotation = '0 ' .. (obj.is_face_down and '180' or '0') .. ' 180',
    height = 48, width = 72, scale = obj.getName() == 'cfighter' and '2 2' or '1 1',
    fontSize = 36, text = 'Hit',
    color = '#' .. Colors[obj.getName()] .. 'd0|#ffffffd0|#000000d0|clear',
    onClick = self.getGUID() .. '/clickHit(' .. obj.getGUID() .. ')'
}}}) end

function assignHit(obj, die, callback)
    local mode, column, pos = combatMode(), getColumn(obj), self.positionToLocal(obj.getPosition())
    local side, y_sign = (mode == 'land') == (pos.x > 0) and 'axis' or 'allies', mode == 'land' and 1 or -1
    local unit, stance = getUnitStance(obj)
    local y, z = 0.1 * (1 + y_sign), ZoneParams[mode].units[unit][stance]
    if die then die.highlightOn({1, 1, 1, 0.7}) end
    if column == 'damaged' or CombatParams[mode].units[unit][stance].hp == 1 then
        pos = self.positionToWorld({ZoneParams[mode].sides[side].casualties, y, z})
        for _, collision in ipairs(Physics.cast({
            origin = pos - vector(0, 0.05, 0),
            direction = {0, 1, 0},
            max_distance = 4
        })) do pos = pos + vector(0, 0.22, 0) end
    else
        local x = ZoneParams[mode].sides[side].damaged
        if column == 'sustained' then x = ZoneParams[mode].sides[side].damaged2
        elseif CombatParams[mode].units[unit][stance].hp == 3 then x = ZoneParams[mode].sides[side].sustained end
        pos = self.positionToWorld({x, y, z})
    end
    obj.setPositionSmooth(pos + vector(0, obj.is_face_down and 0.21 or 0, 0))
    Wait.condition(function ()
        if die then die.destruct() end
        callback()
    end, || not obj.isSmoothMoving())
end

function getColumn(obj)
    local labels = {}
    for _, columns in pairs(ZoneParams[combatMode()].sides) do
        for column, val in pairs(columns) do if column == 'nations' then
            for nation, x in pairs(val) do table.insert(labels, {label = nation, x = x}) end
        elseif column ~= 'units' then table.insert(labels, {label = column:gsub('%d+', ''), x = val})
    end end end
    local pos, closest, label = self.positionToLocal(obj.getPosition()), 100
    for _, column in ipairs(labels) do if math.abs(pos.x - column.x) < closest then closest, label = math.abs(pos.x - column.x), column.label end end
    return label
end

function getUnitStance(obj)
    local pos, closest, unit_label, stance_label = self.positionToLocal(obj.getPosition()), 100
    for unit, stances in pairs(ZoneParams[combatMode()].units) do for stance, z in pairs(stances) do
        if math.abs(pos.z - z) < closest then closest, unit_label, stance_label = math.abs(pos.z - z), unit, stance end
    end end
    return unit_label, stance_label
end

--- Repairs ---

function makeRepairs()
    local mode, count, units = combatMode(), getDamagedUnits()
    if count > 0 then
        repairUnit = function (_, value)
            local guid, resource, stackObj = value:match('^(%w+)-(%a+)-?(%w*)')
            local obj, j = getObjectFromGUID(guid)
            local nation = obj.getVar('nation')
            local Resources = getObjectFromGUID(Global.getTable('GUIDs').Nations[nation].resources)
            local resources = Resources.call('totals')
            for i, unit in ipairs(units[nation]) do if unit.getGUID() == guid then j = i
            elseif resources[resource] == 1 then unit.UI.hide(resource) end end
            table.remove(units[nation], j)
            obj.UI.setXml('')
            stopBlinker(obj)
            if stackObj ~= '' then stack(obj, getObjectFromGUID(stackObj))
            else obj.setPositionSmooth(obj.getPosition():setAt('x', self.positionToWorld({ZoneParams[mode].sides[Alliance[nation]].nations[nation], 0, 0}).x)) end
            Resources.call('addResources', {[resource] = -1})
            Wait.condition(function () count = count - 1 end, || not obj.isSmoothMoving())
        end
        destroyUnit = function (_, guid)
            local obj, j = getObjectFromGUID(guid)
            local nation = obj.getVar('nation')
            for i, unit in ipairs(units[nation]) do if unit.getGUID() == guid then j = i end end
            table.remove(units[nation], j)
            obj.UI.setXml('')
            stopBlinker(obj)
            assignHit(obj, nil, function () count = count - 1 end)
        end
    end
    Wait.condition(function ()
        repairUnit, destroyUnit = nil, nil
        removeCasualties()
        returnUnits()
        resetState()
    end, || count == 0)
end

function getDamagedUnits()
    local mode, count, units = combatMode(), 0, {}
    for side, unit_zones in pairs(Zones.units[mode]) do
        for unit, stances in pairs(unit_zones) do for stance, zone in pairs(stances) do
            local stacks, damaged, sustained, align = {}
            for _, obj in ipairs(zone.getObjects()) do
                align = getColumn(obj)
                if align == 'damaged' then damaged = obj
                elseif align == 'sustained' then sustained = obj
                elseif not stacks[align] or isAbove(obj, stacks[align]) then stacks[align] = obj end
            end
            if sustained then
                local nation = sustained.getVar('nation')
                if stacks[nation] then stack(sustained, stacks[nation])
                else sustained.setPositionSmooth(sustained.getPosition():setAt('x', self.positionToWorld({ZoneParams[mode].sides[side].nations[nation], 0, 0}).x)) end
                stacks[nation] = sustained
            end
            if damaged then
                local nation = damaged.getVar('nation')
                if checkPortAdvantage(side) and unit ~= 'fighter' and unit ~= 'bomber' then
                    if stacks[nation] then stack(damaged, stacks[nation])
                    else damaged.setPositionSmooth(damaged.getPosition():setAt('x', self.positionToWorld({ZoneParams[mode].sides[side].nations[nation], 0, 0}).x)) end
                else
                    count = count + 1
                    if not units[nation] then units[nation] = {} end
                    table.insert(units[nation], damaged)
                    createRepairButtons(damaged, side, stacks[nation])
    end end end end end
    return count, units
end

function createRepairButtons(obj, side, stackObj)
    local nation, sign = obj.getVar('nation'), (side == 'axis' and -1 or 1) * (obj.is_face_down and -1 or 1)
    local scale_factor = obj.getName() == 'cfighter' and 2 or 1
    local x, z = sign * 80 * scale_factor, obj.is_face_down and ' 2' or ' -29'
    local rotation, scale = '0 ' .. (obj.is_face_down and '180' or '0') .. ' 180', scale_factor .. ' ' .. scale_factor
    debug('Creating repair buttons for ', nation, ' ', obj.getName())
    local resources = getObjectFromGUID(Global.getTable('GUIDs').Nations[nation].resources).call('totals')
    local buttons = {
        {tag = 'Image', attributes = {
            position = '0 0' .. z, rotation = rotation, scale = scale,
            height = 50, width = 50,
            image = nation
        }},
        {tag = 'Button', attributes = {
            position = -x .. ' 0' .. z, rotation = rotation, scale = scale,
            height = 40, width = 40,
            text = 'X', fontSize = 32, textColor = 'white',
            colors = 'black|black|black|clear',
            onClick = self.getGUID() .. '/destroyUnit('.. obj.getGUID() .. ')'
        }}
    }
    local y = {oil = 50 * scale_factor, iron = 0, osr = -50 * scale_factor}
    for resource, value in pairs(resources) do
        if value > 0 then
            local onClick = self.getGUID() .. '/repairUnit('.. obj.getGUID() .. '-' .. resource
            if stackObj then onClick = onClick .. '-' .. stackObj.getGUID() end
            table.insert(buttons, {tag = 'Button', attributes = {
                id = resource,
                position = x .. ' ' .. y[resource] .. z, rotation = rotation,
                scale = scale, height = 50, width = 50,
                icon = resource, colors = 'clear|clear|clear|clear',
                onClick = onClick  .. ')'
            }})
    end end
    obj.UI.setXmlTable(buttons)
    setBlinker(obj)
end

--- Combat cleanup ---

function removeCasualties()
    local guids = {}
    for _, zone in pairs(Zones.casualties) do for _, obj in ipairs(zone.getObjects()) do
        debug('Found ', obj.getVar('nation'), ' ', obj.getName(), ' casualty (', obj.getGUID(), ')')
        if obj.getName() ~= 'submarine' or self.positionToLocal(obj.getPosition()).z > 0 then table.insert(guids, obj.getGUID()) end
    end end
    MoraleBoard.call('stackCasualties', guids)
end

function returnUnits()
    local commands, combatants = getCommandStacks()
    local max_delay = 0
    for side, stacks in pairs(commands) do
        local delay = 0
        for num, stack in pairs(stacks) do
            if num == 'cfighter' then for _, unit in ipairs(stack) do
                Wait.frames(function ()
                    local original = unit.getTable('returnTo')
                    if original then
                        unit.setPositionSmooth(original.position)
                        unit.setRotationSmooth(original.rotation)
                    else debug('Couldn\'t return carrier fighter ', unit.getGUID()) end
                end, delay)
                delay = delay + 5
            end elseif #stack.units == 0 then Global.call('returnPieceGUID', {stack.command.getGUID()})
            elseif stack.command.getTable('returnTo') then
                local original = stack.command.getTable('returnTo')
                table.sort(stack.units, |a, b| StackOrder[a.getName()] > StackOrder[b.getName()])
                for i, unit in ipairs(stack.units) do
                    Wait.frames(function ()
                        unit.setPositionSmooth({original.position.x, 6.49 + i * 0.21, original.position.z})
                        unit.setRotationSmooth(original.rotation)
                    end, delay)
                    delay = delay + 5
                end
                Wait.frames(function ()
                    stack.command.setPositionSmooth({original.position.x, 6.7 + #stack.units * 0.21, original.position.z})
                    stack.command.setRotationSmooth(original.rotation)
                    Wait.condition(function ()
                        Wait.frames(|| mergeStack(stack.command, stack.units), 10)
                    end, || not stack.command.isSmoothMoving())
                end, delay)
                delay = delay + 5
            else debug('Couldn\'t return command ', stack.command.getName())
        end end
        max_delay = math.max(max_delay, delay)
    end
    local hotspot = state.hotspot.getGUID()
    Wait.frames(|| Wait.time(|| Global.call('battleDebrief', {hotspot, combatants}), 2), max_delay)
end

function getCommandStacks()
    local mode, commands, combatants = combatMode(), {axis = {cfighter = {}}, allies = {cfighter = {}}}, {}
    for _, obj in ipairs(Zones.commands.getObjects()) do
        if obj.getName() == 'arrow' then obj.destruct()
        else
            local nation, side = getColumn(obj), (mode == 'land') == (self.positionToLocal(obj.getPosition()).x > 0) and 'axis' or 'allies'
            commands[side][obj.getGUID()] = {command = obj, units = {}}
            if not combatants[nation] then table.insert(combatants, nation) end
            combatants[nation] = true
            debug('Found ', nation, ' combatant')
    end end
    for side, stacks in pairs(commands) do
        for unit, stances in pairs(Zones.units[combatMode()][side]) do for _, zone in pairs(stances) do
            for _, obj in ipairs(zone.getObjects()) do if obj.getName() == 'cfighter' then
                local nation = obj.getVar('nation')
                table.insert(stacks.cfighter, obj)
                if not combatants[nation] then table.insert(combatants, nation) end
                combatants[nation] = true
                debug('Found ', nation, ' combatant')
            else
                table.insert(stacks[obj.getVar('command')].units, obj)
                obj.setVar('command', nil)
        end end end end
        if mode == 'sea' then for _, obj in ipairs(Zones.casualties[side].getObjects()) do
            if obj.getName() == 'submarine' and self.positionToLocal(obj.getPosition()).z < 0 then
                table.insert(stacks[obj.getVar('command')].units, obj)
                obj.setVar('command', nil)
    end end end end
    return commands, combatants
end

function resetState()
    local mode = combatMode()
    self.UI.hide(mode .. '-status-panel')
    for _, side in ipairs{'axis', 'allies'} do self.UI.show(mode .. '-' .. side .. '-roll-frame') end
    onObjectEnterScriptingZone, onObjectLeaveScriptingZone = nil, nil
    state = {}
end

--- Setup ---

function combatMode() if self.is_face_down then return 'sea' else return 'land' end end

function loadZones()
    Zones = {
        commands = getObjectFromGUID(ZoneGUIDs.commands),
        units = {byGUID = {}},
        casualties = {
            axis = getObjectFromGUID(ZoneGUIDs.casualties.axis),
            allies = getObjectFromGUID(ZoneGUIDs.casualties.allies)
        }
    }
    for mode, sides in pairs(ZoneGUIDs.units) do
        Zones.units[mode] = {}
        Zones.units.byGUID[mode] = {}
        for side, units in pairs(sides) do
            Zones.units[mode][side] = {}
            for unit, stances in pairs(units) do
                Zones.units[mode][side][unit] = {}
                for stance, guid in pairs(stances) do
                    Zones.units[mode][side][unit][stance] = getObjectFromGUID(guid)
                    Zones.units.byGUID[mode][guid] = {side = side, unit = unit, stance = stance}
    end end end end
    adjustZones()
    adjustSnapPoints()
end

function adjustZones()
    local mode, sign, offset = combatMode(), self.is_face_down and -1 or 1, self.is_face_down and -0.02 or 0.22
    Zones.commands.setPosition(self.positionToWorld({0, offset + sign, ZoneParams[mode].commands}))
    for side, zone in pairs(Zones.casualties) do
        zone.setPosition(self.positionToWorld({ZoneParams[mode].sides[side].casualties, offset + 3 * sign, ZoneParams[mode].casualties}))
    end
    for side, units in pairs(Zones.units[mode]) do
        for unit, stances in pairs(units) do for stance, zone in pairs(stances) do
            zone.setPosition(self.positionToWorld({ZoneParams[mode].sides[side].units, offset + 1.5 * sign, ZoneParams[mode].units[unit][stance]}))
    end end end
end

function adjustSnapPoints()
    local snaps, mode = {}, combatMode()
    local rows = {{x = {}, z = ZoneParams[mode].commands}}
    for _, columns in pairs(ZoneParams[mode].sides) do for _, x in pairs(columns.nations) do table.insert(rows[1].x, x) end end
    if mode == 'sea' then table.insert(rows, {x = {-1.275, 1.27}, z = -0.365}) end
    for unit, stances in pairs(ZoneParams[mode].units) do for stance, z in pairs(stances) do
        local row = {x = {}, z = z}
        for side, columns in pairs(ZoneParams[mode].sides) do
            table.insert(row.x, columns.casualties)
            if mode == 'land' and (unit == 'armor' and stance == 'defensive')
              or mode == 'sea' and (unit == 'battleship' or unit == 'carrier') then
                table.insert(row.x, columns.sustained)
                table.insert(row.x, columns.damaged2)
            elseif unit ~= 'infantry' or stance ~= 'offensive' then table.insert(row.x, columns.damaged) end
            for nation, x in pairs(columns.nations) do
                if nation ~= 'china' or unit == 'infantry' or unit == 'artillery' then table.insert(row.x, x) end
        end end
        table.insert(rows, row)
    end end
    for _, row in ipairs(rows) do for _, x in ipairs(row.x) do table.insert(snaps, {
        position = {x, mode == 'land' and 0.2 or 0, row.z},
        rotation = {0, mode == 'sea' and row.z > -0.36 and 33 * x / math.abs(x) or 0, mode == 'land' and 0 or -180},
        rotation_snap = true
    }) end end
    self.setSnapPoints(snaps)
end

--- Helpers ---

function isAbove(obj1, obj2)
    return obj1.getPosition().y - (obj1.is_face_down and 0.21 or 0) > obj2.getPosition().y - (obj2.is_face_down and 0.21 or 0)
end

function stack(obj1, obj2)
    local pos = obj2.getPosition()
    if obj1.is_face_down then pos = pos + vector(0, 0.21, 0) end
    if obj2.is_face_down then pos = pos + vector(0, 0.01, 0) else pos = pos + vector(0, 0.22, 0) end
    obj1.setPositionSmooth(pos)
end

function setBlinker(obj)
    obj.highlightOn({1, 1, 1}, 0.5)
    obj.setVar('blinker', Wait.time(|| obj.highlightOn({1, 1, 1}, 0.5), 1, -1))
end
function stopBlinker(obj) Wait.stop(obj.getVar('blinker')) end

function other(side) if side == 'axis' then return 'allies' else return 'axis' end end

-- function onCollisionEnter(collision_info)
--     print(self.positionToLocal(collision_info.collision_object.getPosition()))
-- end
