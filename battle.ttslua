#include battle-xml

--- Save and load ---

function onLoad(saved_state)
    state = {}
    self.UI.setXml(XML)
    loadZones()
    HotspotBag = getObjectFromGUID(Global.getTable('GUIDs').Bags.hotspot)
    ArrowBag = getObjectFromGUID(Global.getTable('GUIDs').Bags.arrow)
    DieBags = {getObjectFromGUID(DieGUIDs[1]), getObjectFromGUID(DieGUIDs[2])}
    MoraleBoard = getObjectFromGUID(Global.getTable('GUIDs').MoraleBoard)
    StackOrder = Global.getTable('StackOrder')
    for i, unit in ipairs(StackOrder) do StackOrder[unit] = i end
end

--- Combat setup ---

function flipBoard()
    local sign = self.is_face_down and -1 or 1
    self.setPositionSmooth(self.getPosition() + vector(0, 0.2, 0) * sign)
    self.setRotationSmooth(self.getRotation() + vector(0, 0, 180) * sign)
end

function setupCombat(data)
    local setup = data[1]
    state.hotspot = data[2]
    if (setup == 'land') == self.is_face_down then
        flipBoard()
        Wait.condition(function ()
            adjustZones()
            adjustSnapPoints()
        end, || not self.isSmoothMoving())
    end
end

function isReady() return not state.hotspot end

function setStances()
    local mode, unit_types, ready = combatMode(), {}, {}
    state.dice = {}
    for side, zones in pairs(Zones.units[mode]) do
        self.UI.setAttribute(mode .. '-' .. side .. '-roll-frame', 'active', false)
        self.UI.setAttributes(mode .. '-confirm-' .. side, {
            text = 'OK?',
            textColor = 'white',
            onClick = 'stancesReady(' .. side .. ')',
            interactable = true,
            active = true
        })
        state.dice[side] = {}
        for stage, _ in pairs(CombatParams[mode].stages) do
            state.dice[side][stage] = 0
            self.UI.setAttribute(mode .. '-' .. side .. '-' .. stage .. '-image', 'active', true)
            self.UI.setAttribute(mode .. '-' .. side .. '-' .. stage .. '-dice', 'active', true)
        end
        unit_types[side] = 0
        for unit, stances in pairs(zones) do
            local has_unit = false
            for stance, zone in pairs(stances) do
                local count = countUnits(zone, unit)
                if count > 0 then
                    has_unit = true
                    addDice(state.dice[side], CombatParams[mode].units[unit][stance].dice, count)
                    updateDiceText(side)
            end end
            if has_unit and unit ~= 'fighter' and unit ~= 'bomber' then unit_types[side] = unit_types[side] + 1 end
    end end
    onObjectEnterScriptingZone = |zone, obj| updateUnitDice(zone, obj, 1)
    onObjectLeaveScriptingZone = |zone, obj| updateUnitDice(zone, obj, -1)
    stancesReady = function (_, side)
        ready[side] = true
        self.UI.setAttributes(mode .. '-confirm-' .. side, {
            text = 'OK',
            interactable = false
        })
        if ready.axis and ready.allies then
            stancesReady = nil
            setupStage('air')
        end
    end
    setForceAdvantage(unit_types.axis, unit_types.allies)
end

function getDropPoints()
    local mode, points = combatMode(), {x = {}, z = {}}
    points.y = 0.1 * (mode == 'land' and 2 or 0)
    points.z.command = ZoneParams[mode].commands
    for _, columns in pairs(ZoneParams[mode].sides) do for nation, x in pairs(columns.nations) do points.x[nation] = x end end
    for unit, stances in pairs(ZoneParams[mode].units) do
        points.z[unit] = stances.antiair or stances.air or stances.ground or stances.surface or stances.escort or stances.defensive or stances.dive
    end
    return points
end

--- Tracking dice totals ---

function updateUnitDice(zone, obj, count)
    local info = Zones.units.byGUID[combatMode()][zone.getGUID()]
    if info and obj.getName():find(info.unit) then
        addDice(state.dice[info.side], CombatParams[combatMode()].units[info.unit][info.stance].dice, count)
        updateDiceText(info.side)
    end
end

function addDice(totals, per_unit, units)
    for stage, n in pairs(totals) do totals[stage] = n + (per_unit[stage] or 0) * units end
end

function countUnits(zone, unit)
    local count = 0
    for _, obj in ipairs(zone.getObjects()) do if obj.getName():find(unit) then count = count + 1 end end
    return count
end

function countStageUnits(side, stage)
    local total, mode = 0, combatMode()
    for _, unit in pairs(CombatParams[mode].stages[stage]) do
        for stance, zone in pairs(Zones.units[mode][side][unit]) do total = total + countUnits(zone, unit) end
    end
    return total
end

function updateDiceText(side)
    for stage, value in pairs(state.dice[side]) do self.UI.setValue(combatMode() .. '-' .. side .. '-' .. stage .. '-dice', math.min(value, 30)) end
end

--- Force and Port Advantage ---

function setForceAdvantage(axis, allies)
    local adv, mode = axis - allies, combatMode()
    if adv ~= 0 then
        local mode_sign = mode == 'land' and 1 or -1
        local side = math.abs(adv) / adv * mode_sign
        ArrowBag.takeObject({
            position = self.positionToWorld({0.12 * side, 2 * mode_sign, ZoneParams[combatMode()].commands - (mode == 'sea' and 0.06 or 0)}),
            rotation = self.getRotation() + vector(90 + 90 * side, 90 * mode_sign, 0),
            smooth = false
        })
    end
end

function checkForceAdvantage()
    for _, obj in ipairs(Zones.commands.getObjects()) do
        if obj.getName() == 'arrow' and (combatMode() == 'land' or self.positionToLocal(obj.getPosition()).z < ZoneParams.sea.commands) then
            if obj.is_face_down then return 'axis' else return 'allies' end
    end end
    return nil
end

function setPortAdvantage(side)
    if type(side) == 'table' then side = side[1] end
    local sign = side == 'axis' and -1 or 1
    if combatMode() == 'sea' then ArrowBag.takeObject({
        position = self.positionToWorld({0.12 * sign, -2, ZoneParams.sea.commands + 0.06}),
        rotation = self.getRotation() + vector(90 + 90 * sign, 90, 0),
        smooth = false
    }) end
    state.dice[side].surface = state.dice[side].surface + 2
    updateDiceText(side)
end

function checkPortAdvantage(side)
    if combatMode() == 'sea' then for _, obj in ipairs(Zones.commands.getObjects()) do
        if obj.getName() == 'arrow' and self.positionToLocal(obj.getPosition()).z > ZoneParams.sea.commands then
            if (side == 'axis') == obj.is_face_down then return true end
    end end end
    return false
end

--- Combat stage setup ---

function setupStage(stage)
    local roll_flag, mode = false, combatMode()
    for side, _ in pairs(state.dice) do
        self.UI.setAttribute(mode .. '-' .. side .. '-' .. stage .. '-image', 'active', false)
        self.UI.setAttribute(mode .. '-' .. side .. '-' .. stage .. '-dice', 'active', false)
        if state.dice[side][stage] > 0 and (stage == 'bomb' or countStageUnits(other(side), stage) > 0) then
            roll_flag = true
            self.UI.setAttributes(mode .. '-confirm-' .. side, {
                text = 'Roll',
                textColor = 'white',
                onClick = 'rollRound(' .. side .. '-' .. stage .. ')',
                interactable = true
            })
            setHotspotCounters(side, stage, math.min(state.dice[side][stage], 30))
        else setWaitButton(side) end
    end
    if not roll_flag then
        if stage == 'air' then if mode == 'land' then setupStage('bomb') else setupStage('surface') end
        elseif stage == 'bomb' then setupStage('ground')
        else makeRepairs() end
    end
end

function setWaitButton(side)
    self.UI.setAttributes(combatMode() .. '-confirm-' .. side, {
        text = 'Wait',
        textColor = 'white',
        interactable = false
    })
end

function setHotspotCounters(side, stage, num)
    local mode = combatMode()
    local y_sign = mode == 'land' and 1 or -1
    local y_inc, x_sign = 0.71 * y_sign, (side == 'axis' and 1 or -1) * y_sign
    local x, y, z_min = 1.5 * x_sign, 0.1 * (1 + y_sign) + y_inc / 2, ZoneParams.land.units.bomber.strategic
    local start = self.positionToWorld({(mode == 'land' and 0.95 or 0.89) * x_sign, y, ZoneParams[mode].commands})
    if stage == 'bomb' then while num > 0 do
        num = num - 4
        setHotspotCounter(start, self.positionToWorld({x, y, ZoneParams.land.units.armor.offensive}))
        y = y + y_inc
    end else
        setHotspotCounter(start, self.positionToWorld({x, y, (30 - num) % 10 * 0.173 + z_min}))
        if num % 10 == 0 then y = y + y_inc end
        if num > 10 then setHotspotCounter(start, self.positionToWorld({x, y, z_min})) end
        y = y + y_inc
        if num > 20 then setHotspotCounter(start, self.positionToWorld({x, y, z_min})) end
    end
end

function setHotspotCounter(start, moveTo)
    HotspotBag.takeObject({
        position = start,
        smooth = false,
        callback_function = |obj| Wait.condition(|| obj.setPositionSmooth(moveTo, false, true), || not obj.spawning)
    })
end

--- Roll dice ---

function rollRound(_, info)
    local args, mode = {}, combatMode()
    for arg in info:gmatch('%a+') do table.insert(args, arg) end
    local side, stage, next = args[1], args[2], args[3]
    if not next and self.UI.getAttribute(mode .. '-confirm-' .. other(side), 'interactable') == 'True' then next = other(side) end
    for side, _ in pairs(state.dice) do self.UI.setAttributes(mode .. '-confirm-' .. side, {
        text = 'Wait',
        textColor = 'white',
        interactable = false
    }) end
    local num, more = getRollCounter(side)
    broadcastToAll(colorize(side) .. '[-] rolling ' .. num .. ' dice')
    local callback = function ()
        local ready = false
        if mode == 'sea' then
            local wait_fun
            for _, unit in ipairs(Zones.units[mode][other(side)].submarine.dive.getObjects()) do
                if getColumn(unit) == 'damaged' then
                    unit.setVar('nation', nil)
                    unit.setPositionSmooth(self.positionToWorld({other(side) == 'axis' and -1.275 or 1.27, -0.63, -0.365}))
                    unit.setRotationSmooth({0, self.getRotation().y, 0})
                    wait_fun = Wait.condition(function () ready = true end, || not unit.isSmoothMoving())
                    break
            end end
            if not wait_fun then ready = true end
        else ready = true end
        Wait.condition(function ()
            if next or more then
                local onClick = 'rollRound(' .. (next or side) .. '-' .. stage
                if next and more then onClick = onClick .. '-' .. side end
                self.UI.setAttributes(mode .. '-confirm-' .. (next or side), {
                    text = 'Roll',
                    textColor = 'white',
                    onClick = onClick .. ')',
                    interactable = true
                })
            else
                if stage == 'air' then
                    broadcastToAll('Air battle stage complete')
                    setupStage(mode == 'land' and 'bomb' or 'surface')
                elseif stage == 'bomb' then
                    broadcastToAll('Strategic bombing complete')
                    setupStage('ground')
                else
                    broadcastToAll((mode == 'land' and 'Ground' or 'Surface') .. ' battle stage complete')
                    makeRepairs()
        end end end, || ready)
    end
    rollDice(num, function (results)
        local a, b = 1, #results.objs
        while a < b do results.objs[a], results.objs[b], a, b = results.objs[b], results.objs[a], a + 1, b - 1 end
        if stage == 'bomb' then assignBombs(results.objs, callback)
        else assignHits(side, stage, results.objs, callback) end
    end)
end

function getRollCounter(side)
    local mode, counter, more = combatMode()
    local y_sign = mode == 'land' and 1 or -1
    local x_sign = (side == 'axis' and 1 or -1) * y_sign
    local origin = self.positionToWorld({1.5 * x_sign, 0.1 + 0.455 * y_sign, -1.05})
    for _, obj in ipairs(Physics.cast({
        origin = origin,
        direction = self.getTransformForward(),
        max_distance = 15
    })) do if not counter then counter = obj.hit_object
        else
            more = true
            if obj.hit_object.getPosition():distance(origin) < counter.getPosition():distance(origin) then counter = obj.hit_object end
    end end
    if not more then for _, _ in ipairs(Physics.cast({
        origin = counter.getPosition() + vector(0, 0.2, 0),
        direction = {0, 1, 0},
        max_distance = 5
    })) do more = true end end
    local num = math.floor((16.3 - counter.getPosition():distance(origin)) / 1.47 + 0.1)
    counter.destruct()
    return num, more
end

function rollClick(_, _, id)
    local side, num = id:match('%a+%-roll%-(%a+)%-(%d+)$')
    broadcastToAll(colorize(side) .. '[-] rolling ' .. num .. ' dice')
    rollDice(num + 0)
end

function clearRollArea()
    --print('')
    return nil
end

function rollDice(num, callback)
    clearRollArea()
    local roll, i = {objs = {}}, 0
    if not callback then callback = || nil end
    Wait.time(function ()
        local bag, other = DieBags[i % 2 + 1], DieBags[(i + 1) % 2 + 1]
        local force = vector(
            bag.positionToLocal(other.getPosition()).x * (math.random() / 2.5 + 0.15),
            math.random() * 5 + 3,
            (math.random() - 0.5) * 5
        )
        rollDie(i + 1, bag, force, roll)
        i = i + 1
    end, 0.15, num)
    Wait.condition(function ()
        arrangeResults(roll)
        Wait.condition(|| callback(roll), || not roll.objs[num].isSmoothMoving())
    end, || roll.objs[num] ~= nil)
end

function rollDie(index, bag, force, results)
    bag.takeObject({
        position = bag.getPosition() + vector(0, 3, 0),
        rotation = vector(math.random(360), 0, math.random(360)),
        smooth = false,
        callback_function = function (obj)
            obj.use_gravity = false
            Wait.time(function ()
                obj.use_gravity = true
                obj.addForce(force)
                obj.addTorque({math.random() * 2, math.random() * 2, math.random() * 2})
                Wait.time(function () results.objs[index] = obj end, 3)
            end, 0.2)
        end
    })
end

function arrangeResults(roll)
    local left, right = DieBags[1].getPosition() + vector(0, 0.5, 0), DieBags[2].getPosition() + vector(0, 0.5, 0)
    table.sort(roll.objs, |a, b| UIColors.order[getDieColor(a)] < UIColors.order[getDieColor(b)])
    roll.result = {}
    local msg = ''
    for i, die in ipairs(roll.objs) do
        roll.result[getDieColor(die)] = (roll.result[getDieColor(die)] or 0) + 1
        die.setPositionSmooth(left:lerp(right, 0.47 - #roll.objs * 0.03 + i * 0.06))
        die.setRotationSmooth(die.getRotationValues()[die.getValue()].rotation)
    end
    for color, num in pairs(roll.result) do msg = msg .. UIColors.text[color] .. num .. '[-], ' end
    broadcastToAll('Roll result: ' .. msg:sub(1, -6))
end

function getDieColor(die) return die.getRotationValue():sub(9):lower() end

--- Assign hits ---

function assignBombs(dice, callback)
    print('Bomb assignment not implemented')
    callback()
end

function assignHits(side, stage, dice, callback)
    local skips, waiting
    local fd = checkForceAdvantage() == other(side)
    if stage == 'air' then skips = 'yellow,blue'
    elseif stage == 'ground' then skips = 'red'
    else skips = '' end
    if stage ~= 'air' and fd then skips = 'black,white,' .. skips end
    while #dice > 0 and not waiting do
        local die = table.remove(dice)
        local color = getDieColor(die)
        if skips:match(color) then die.destruct()
        else
            local targets = getTargets(side, stage, color)
            if #targets == 0 then
                die.destruct()
                skips = color .. ',' .. skips
            else
                waiting = true
                local hit_callback = || assignHits(side, stage, dice, callback)
                if #targets > 1 then createHitButtons(die, targets, hit_callback)
                else assignHit(targets[1], die, hit_callback) end
    end end end
    if #dice == 0 and not waiting then callback() end
end

function getTargets(side, stage, color)
    local mode, units, targets = combatMode(), {}, {}
    local escort, escort_targeted
    if color == 'black' or color == 'white' then
        for _, unit in pairs(CombatParams[mode].stages[stage]) do table.insert(units, unit) end
    else table.insert(units, CombatParams[mode].stages[stage][color]) end
    for _, unit in ipairs(units) do
        for stance, zone in pairs(Zones.units[combatMode()][other(side)][unit]) do
            for _, t in ipairs(getTarget(zone, unit, color == 'white')) do
                table.insert(targets, t)
                if unit == 'carrier' or unit == 'battleship' then escort = true end
                if stance == 'escort' then escort_targeted = true end
    end end end
    if escort and not escort_targeted then
        for _, t in ipairs(getTarget(Zones.units[combatMode()][other(side)].cruiser.escort, 'cruiser')) do table.insert(targets, t) end
    end
    return targets
end

function getTarget(zone, unit, white_hit)
    local units, targets = {}, {}
    for _, obj in ipairs(zone.getObjects()) do if obj.getName():match(unit) then
        local align = getColumn(obj)
        if not units[align] or isAbove(obj, units[align]) then units[align] = obj end
    end end
    if units['damaged'] and (unit ~= 'submarine' or not white_hit) then table.insert(targets, units['damaged'])
    elseif not white_hit then
        if units['sustained'] then table.insert(targets, units['sustained'])
        else for nation, obj in pairs(units) do table.insert(targets, obj) end end
    end
    return targets
end

function createHitButtons(die, targets, callback)
    setBlinker(die)
    for _, target in ipairs(targets) do
        setBlinker(target)
        createHitButton(target)
    end
    clickHit = function (_, guid)
        stopBlinker(die)
        for _, target in ipairs(targets) do
            stopBlinker(target)
            target.UI.setXml('')
        end
        assignHit(getObjectFromGUID(guid), die, || callback())
        clickHit = nil
    end
end

function createHitButton(obj)
    obj.UI.setXmlTable({{tag = 'Button', attributes = {
        position = '0 0 -29',
        rotation = '0 0 180',
        height = 48,
        width = 72,
        scale = obj.getName() == 'cfighter' and '1.2 1.2' or '1 1',
        fontSize = 36,
        text = 'Hit',
        color = UIColors.button[obj.getName()] .. '|rgba(1,1,1,0.8)|rgba(0,0,0,0.8)|clear',
        onClick = self.getGUID() .. '/clickHit(' .. obj.getGUID() .. ')'
    }}})
end

function assignHit(obj, die, callback)
    local mode, column, pos = combatMode(), getColumn(obj), self.positionToLocal(obj.getPosition())
    local side, y_sign = (mode == 'land') == (pos.x > 0) and 'axis' or 'allies', mode == 'land' and 1 or -1
    local unit, stance = getUnitStance(obj)
    local y, z = 0.1 * (1 + y_sign), ZoneParams[mode].units[unit][stance]
    if die then die.highlightOn({1, 1, 1, 0.7}) end
    if column ~= 'damaged' and column ~= 'sustained' then obj.setVar('nation', column) end
    if column == 'damaged' or CombatParams[mode].units[unit][stance].hp == 1 then
        pos = self.positionToWorld({ZoneParams[mode].sides[side].casualties, y, z})
        for _, collision in ipairs(Physics.cast({
            origin = pos - vector(0, 0.05, 0),
            direction = {0, 1, 0},
            max_distance = 4
        })) do pos = pos + vector(0, 0.22, 0) end
    else
        local x = ZoneParams[mode].sides[side].damaged
        if column == 'sustained' then x = ZoneParams[mode].sides[side].damaged2
        elseif CombatParams[mode].units[unit][stance].hp == 3 then x = ZoneParams[mode].sides[side].sustained end
        pos = self.positionToWorld({x, y, z})
    end
    obj.setPositionSmooth(pos + vector(0, obj.is_face_down and 0.21 or 0, 0))
    Wait.condition(function ()
        if die then die.destruct() end
        callback()
    end, || not obj.isSmoothMoving())
end

function getColumn(obj)
    local labels = {}
    for _, columns in pairs(ZoneParams[combatMode()].sides) do
        for column, val in pairs(columns) do if column == 'nations' then
            for nation, x in pairs(val) do table.insert(labels, {label = nation, x = x}) end
        elseif column ~= 'units' then table.insert(labels, {label = column:gsub('%d+', ''), x = val})
    end end end
    local pos, closest, label = self.positionToLocal(obj.getPosition()), 100
    for _, column in ipairs(labels) do if math.abs(pos.x - column.x) < closest then closest, label = math.abs(pos.x - column.x), column.label end end
    return label
end

function getUnitStance(obj)
    local pos, closest, unit_label, stance_label = self.positionToLocal(obj.getPosition()), 100
    for unit, stances in pairs(ZoneParams[combatMode()].units) do for stance, z in pairs(stances) do
        if math.abs(pos.z - z) < closest then closest, unit_label, stance_label = math.abs(pos.z - z), unit, stance end
    end end
    return unit_label, stance_label
end

--- Repairs ---

function makeRepairs()
    local mode, count, units = combatMode(), getDamagedUnits()
    if count > 0 then
        repairUnit = function (_, value)
            local guid, resource, stackObj = value:match('^(%w+)-(%a+)-?(%w*)')
            local obj, j = getObjectFromGUID(guid)
            local nation = obj.getVar('nation')
            local Resources = getObjectFromGUID(Global.getTable('GUIDs').Nations[nation].resources)
            local resources = Resources.call('totals')
            for i, unit in ipairs(units[nation]) do if unit.getGUID() == guid then j = i
            elseif resources[resource] == 1 then unit.UI.hide(resource) end end
            table.remove(units[nation], j)
            obj.UI.setXml('')
            if obj.getName() ~= 'cfighter' then obj.setVar('nation', nil) end
            stopBlinker(obj)
            if stackObj ~= '' then stack(obj, getObjectFromGUID(stackObj))
            else obj.setPositionSmooth(obj.getPosition():setAt('x', self.positionToWorld({ZoneParams[mode].sides[alliance(nation)].nations[nation], 0, 0}).x)) end
            Resources.call('addResources', {[resource] = -1})
            Wait.condition(function () count = count - 1 end, || not obj.isSmoothMoving())
        end
        destroyUnit = function (_, guid)
            local obj, j = getObjectFromGUID(guid)
            local nation = obj.getVar('nation')
            for i, unit in ipairs(units[nation]) do if unit.getGUID() == guid then j = i end end
            table.remove(units[nation], j)
            obj.UI.setXml('')
            stopBlinker(obj)
            assignHit(obj, nil, function () count = count - 1 end)
        end
    end
    Wait.condition(function ()
        repairUnit, destroyUnit = nil, nil
        removeCasualties()
        returnUnits()
        resetState()
    end, || count == 0)
end

function getDamagedUnits()
    local mode, count, units = combatMode(), 0, {}
    for side, unit_zones in pairs(Zones.units[mode]) do
        for unit, stances in pairs(unit_zones) do for stance, zone in pairs(stances) do
            local stacks, damaged, sustained, align = {}
            for _, obj in ipairs(zone.getObjects()) do
                align = getColumn(obj)
                if align == 'damaged' then damaged = obj
                elseif align == 'sustained' then sustained = obj
                elseif not stacks[align] or isAbove(obj, stacks[align]) then stacks[align] = obj end
            end
            if sustained then
                local nation = sustained.getVar('nation')
                if stacks[nation] then stack(sustained, stacks[nation])
                else sustained.setPositionSmooth(sustained.getPosition():setAt('x', self.positionToWorld({ZoneParams[mode].sides[side].nations[nation], 0, 0}).x)) end
                stacks[nation] = sustained
                sustained.setVar('nation', nil)
            end
            if damaged then
                local nation = damaged.getVar('nation')
                if checkPortAdvantage(side) and unit ~= 'fighter' and unit ~= 'bomber' then
                    if stacks[nation] then stack(damaged, stacks[nation])
                    else damaged.setPositionSmooth(damaged.getPosition():setAt('x', self.positionToWorld({ZoneParams[mode].sides[side].nations[nation], 0, 0}).x)) end
                    damaged.setVar('nation', nil)
                else
                    count = count + 1
                    if not units[nation] then units[nation] = {} end
                    table.insert(units[nation], damaged)
                    createRepairButtons(damaged, side, stacks[nation])
    end end end end end
    return count, units
end

function createRepairButtons(obj, side, stackObj)
    local nation, is_cfighter, sign = obj.getVar('nation'), obj.getName() == 'cfighter', side == 'axis' and -1 or 1
    print('Creting repair buttons for ', nation, ' ', obj.getName())
    local resources = getObjectFromGUID(Global.getTable('GUIDs').Nations[nation].resources).call('totals')
    local buttons = {
        {tag = 'Image', attributes = {
            position = '0 0 -29',
            rotation = '0 0 180',
            scale = is_cfighter and '1.2 1.2' or '1 1',
            height = 50,
            width = 50,
            image = nation
        }},
        {tag = 'Button', attributes = {
            position = (sign * -80) .. ' 0 -29',
            rotation = '0 0 180',
            scale = is_cfighter and '1.2 1.2' or '1 1',
            height = 40,
            width = 40,
            text = 'X',
            fontSize = 32,
            textColor = 'white',
            colors = 'black|black|black|clear',
            onClick = self.getGUID() .. '/destroyUnit('.. obj.getGUID() .. ')'
        }}
    }
    local y = {oil = 50, iron = 0, osr = -50}
    for resource, value in pairs(resources) do
        if value > 0 then
            local onClick = self.getGUID() .. '/repairUnit('.. obj.getGUID() .. '-' .. resource
            if stackObj then onClick = onClick .. '-' .. stackObj.getGUID() end
            table.insert(buttons, {tag = 'Button', attributes = {
                id = resource,
                position = (sign * 80) .. ' ' .. y[resource] .. ' -29',
                rotation = '0 0 180',
                scale = is_cfighter and '1.2 1.2' or '1 1',
                height = 50,
                width = 50,
                icon = resource,
                colors = 'clear|clear|clear|clear',
                onClick = onClick  .. ')'
            }})
        end
    end
    obj.UI.setXmlTable(buttons)
    setBlinker(obj)
end

--- Combat cleanup ---

function removeCasualties()
    local guids = {}
    for _, zone in pairs(Zones.casualties) do for _, obj in ipairs(zone.getObjects()) do
        print('Found ', obj.getVar('nation'), ' ', obj.getName(), ' casualty (', obj.getGUID(), ')')
        if obj.getName() ~= 'submarine' or self.positionToLocal(obj.getPosition()).z > 0 then table.insert(guids, obj.getGUID()) end
    end end
    MoraleBoard.call('stackCasualties', guids)
end

function returnUnits()
    local mode, commands, combatants, hotspot = combatMode(), {axis = {cfighter = {}}, allies = {cfighter = {}}}, {}, state.hotspot
    for _, obj in ipairs(Zones.commands.getObjects()) do
        if obj.getName() == 'arrow' then obj.destruct()
        else
            local nation, side = getColumn(obj), (mode == 'land') == (self.positionToLocal(obj.getPosition()).x > 0) and 'axis' or 'allies'
            commands[side][obj.getGUID()] = {command = obj, units = {}}
            if not combatants[nation] then table.insert(combatants, nation) end
            combatants[nation] = true
    end end
    for side, stacks in pairs(commands) do
        for unit, stances in pairs(Zones.units[combatMode()][side]) do for _, zone in pairs(stances) do for _, obj in ipairs(zone.getObjects()) do
            if obj.getName() == 'cfighter' then
                local nation = obj.getVar('nation')
                table.insert(stacks.cfighter, obj)
                if not combatants[nation] then table.insert(combatants, nation) end
                combatants[nation] = true
            else
                table.insert(stacks[obj.getVar('command')].units, obj)
                obj.setVar('command', nil)
        end end end end
        if mode == 'sea' then for _, obj in ipairs(Zones.casualties[side].getObjects()) do
            if obj.getName() == 'submarine' and self.positionToLocal(obj.getPosition()).z < 0 then
                table.insert(stacks[obj.getVar('command')].units, obj)
                obj.setVar('command', nil)
        end end end
    end
    local max_delay = 0
    for side, stacks in pairs(commands) do
        local delay = 0
        for num, stack in pairs(stacks) do
            if num == 'cfighter' then for _, unit in ipairs(stack) do
                Wait.frames(function ()
                    local original = unit.getTable('returnTo')
                    unit.setPositionSmooth(original.position)
                    unit.setRotationSmooth(original.rotation)
                end, delay)
                delay = delay + 5
            end elseif #stack.units == 0 then Global.call('returnPieceGUID', {stack.command.getGUID()})
            else
                local original = stack.command.getTable('returnTo')
                table.sort(stack.units, |a, b| StackOrder[a.getName()] > StackOrder[b.getName()])
                stack.units.guids = {}
                for i, unit in ipairs(stack.units) do
                    table.insert(stack.units.guids, unit.getGUID())
                    Wait.frames(function ()
                        unit.setPositionSmooth({original.position.x, 6.49 + i * 0.21, original.position.z})
                        unit.setRotationSmooth(original.rotation)
                    end, delay)
                    delay = delay + 5
                end
                Wait.frames(function ()
                    stack.command.setPositionSmooth({original.position.x, 6.7 + #stack.units * 0.21, original.position.z})
                    stack.command.setRotationSmooth(original.rotation)
                    Wait.time(|| Global.call('mergeStackGUIDs', {stack.command.getGUID(), stack.units.guids}), 1.5)
                end, delay)
                delay = delay + 5
        end end
        max_delay = math.max(max_delay, delay)
    end
    Wait.frames(|| Wait.time(|| Global.call('battleDebrief', {hotspot, combatants}), 2), max_delay)
end

function resetState()
    local mode = combatMode()
    for side, _ in pairs(state.dice) do
        self.UI.setAttribute(mode .. '-confirm-' .. side, 'active', false)
        self.UI.setAttribute(mode .. '-' .. side .. '-roll-frame', 'active', true)
    end
    onObjectEnterScriptingZone = nil
    onObjectLeaveScriptingZone = nil
    state = {}
end

--- Setup ---

function combatMode()
    if self.is_face_down then return 'sea' else return 'land' end
end

function loadZones()
    Zones = {
        commands = getObjectFromGUID(ZoneGUIDs.commands),
        units = {byGUID = {}},
        casualties = {
            axis = getObjectFromGUID(ZoneGUIDs.casualties.axis),
            allies = getObjectFromGUID(ZoneGUIDs.casualties.allies)
        }
    }
    for mode, sides in pairs(ZoneGUIDs.units) do
        Zones.units[mode] = {}
        Zones.units.byGUID[mode] = {}
        for side, units in pairs(sides) do
            Zones.units[mode][side] = {}
            for unit, stances in pairs(units) do
                Zones.units[mode][side][unit] = {}
                for stance, guid in pairs(stances) do
                    Zones.units[mode][side][unit][stance] = getObjectFromGUID(guid)
                    Zones.units.byGUID[mode][guid] = {side = side, unit = unit, stance = stance}
    end end end end
    adjustZones()
    adjustSnapPoints()
end

function adjustZones()
    local mode, sign, offset = combatMode(), self.is_face_down and -1 or 1, self.is_face_down and -0.02 or 0.22
    Zones.commands.setPosition(self.positionToWorld({0, offset + sign, ZoneParams[mode].commands}))
    for side, zone in pairs(Zones.casualties) do
        zone.setPosition(self.positionToWorld({ZoneParams[mode].sides[side].casualties, offset + 3 * sign, ZoneParams[mode].casualties}))
    end
    for side, units in pairs(Zones.units[mode]) do
        for unit, stances in pairs(units) do for stance, zone in pairs(stances) do
            zone.setPosition(self.positionToWorld({ZoneParams[mode].sides[side].units, offset + 1.5 * sign, ZoneParams[mode].units[unit][stance]}))
    end end end
end

function adjustSnapPoints()
    local snaps, mode = {}, combatMode()
    local rows = {{x = {}, z = ZoneParams[mode].commands}}
    for _, columns in pairs(ZoneParams[mode].sides) do for _, x in pairs(columns.nations) do table.insert(rows[1].x, x) end end
    if mode == 'sea' then table.insert(rows, {x = {-1.275, 1.27}, z = -0.365}) end
    for unit, stances in pairs(ZoneParams[mode].units) do for stance, z in pairs(stances) do
        local row = {x = {}, z = z}
        for side, columns in pairs(ZoneParams[mode].sides) do
            table.insert(row.x, columns.casualties)
            if mode == 'land' and (unit == 'armor' and stance == 'defensive')
              or mode == 'sea' and (unit == 'battleship' or unit == 'carrier') then
                table.insert(row.x, columns.sustained)
                table.insert(row.x, columns.damaged2)
            elseif unit ~= 'infantry' or stance ~= 'offensive' then table.insert(row.x, columns.damaged) end
            for nation, x in pairs(columns.nations) do
                if nation ~= 'china' or unit == 'infantry' or unit == 'artillery' then table.insert(row.x, x) end
        end end
        table.insert(rows, row)
    end end
    for _, row in ipairs(rows) do for _, x in ipairs(row.x) do table.insert(snaps, {
        position = {x, mode == 'land' and 0.2 or 0, row.z},
        rotation = {0, mode == 'sea' and row.z > -0.36 and 33 * x / math.abs(x) or 0, mode == 'land' and 0 or -180},
        rotation_snap = true
    }) end end
    self.setSnapPoints(snaps)
end

--- Helpers ---

function isAbove(obj1, obj2)
    return obj1.getPosition().y - (obj1.is_face_down and 0.21 or 0) > obj2.getPosition().y - (obj2.is_face_down and 0.21 or 0)
end

function stack(obj1, obj2)
    local pos = obj2.getPosition()
    if obj1.is_face_down then pos = pos + vector(0, 0.21, 0) end
    if obj2.is_face_down then pos = pos + vector(0, 0.01, 0) else pos = pos + vector(0, 0.22, 0) end
    obj1.setPositionSmooth(pos)
end

function setBlinker(obj)
    obj.highlightOn({1, 1, 1}, 0.5)
    obj.setVar('blinker', Wait.time(|| obj.highlightOn({1, 1, 1}, 0.5), 1, -1))
end
function stopBlinker(obj) Wait.stop(obj.getVar('blinker')) end

function alliance(nation)
    if nation == 'germany' or nation == 'italy' or nation == 'japan' then return 'axis' else return 'allies' end
end

function other(side) if side == 'axis' then return 'allies' else return 'axis' end end
function colorize(side) if side == 'axis' then return '[C08080]Axis' else return '[A0A0FF]Allies' end end

-- function onCollisionEnter(collision_info)
--     print(self.positionToLocal(collision_info.collision_object.getPosition()))
-- end
