function removeCasualties()
    local guids = {}
    for _, zone in pairs(Zones.casualties) do for _, obj in ipairs(zone.getObjects()) do
        debug('Found ', obj.getVar('nation'), ' ', obj.getName(), ' casualty (', obj.getGUID(), ')')
        if obj.getVar('nation'):match('neutral') then obj.destruct()
        elseif obj.getName() ~= 'submarine' or self.positionToLocal(obj.getPosition()).z > 0 then table.insert(guids, obj.getGUID()) end
    end end
    MoraleBoard.call('stackCasualties', guids)
end

function returnUnits()
    local commands, combatants = getCommandStacks()
    local max_delay = 0
    for side, stacks in pairs(commands) do
        local delay = 0
        for num, stack in pairs(stacks) do
            if num == 'cfighter' then for _, unit in ipairs(stack) do
                Wait.frames(function ()
                    local original = unit.getTable('returnTo')
                    if original then
                        unit.setLock(true)
                        unit.setPositionSmooth(original.position)
                        unit.setRotationSmooth(original.rotation)
                    else debug('Couldn\'t return carrier fighter ', unit.getGUID()) end
                end, delay)
                delay = delay + 5
            end elseif num == 'defense' then delay = returnDefenseForces(stack, delay)
            elseif #stack.units == 0 then Global.call('returnPieceGUID', {stack.command.getGUID()})
            elseif stack.command.getTable('returnTo') then
                local original = stack.command.getTable('returnTo')
                delay = returnStack(stack.command, stack.units, original, delay)
            else debug('Couldn\'t return command ', stack.command.getName())
        end end
        max_delay = math.max(max_delay, delay)
    end
    local hotspot = state.hotspot.getGUID()
    Wait.frames(|| Wait.time(|| Global.call('battleDebrief', {hotspot, combatants}), 3), max_delay)
end

function returnStack(command, units, original, delay)
    table.sort(units, |a, b| StackOrder[a.getName()] > StackOrder[b.getName()])
    for i, unit in ipairs(units) do
        Wait.frames(function ()
            unit.setPositionSmooth({original.position.x, 6.49 + i * 0.21, original.position.z})
            unit.setRotationSmooth(original.rotation)
        end, delay)
        delay = delay + 5
    end
    Wait.frames(function ()
        command.setPositionSmooth({original.position.x, 6.7 + #units * 0.21, original.position.z})
        command.setRotationSmooth(original.rotation)
        Wait.condition(|| Wait.frames(|| mergeStack(command, units), 10), || not command.isSmoothMoving())
    end, delay)
    return delay + 5
end

function returnDefenseForces(stack, delay)
    local unit = (stack.air or stack.army)[1]
    local nation, return_to = unit.getVar('nation'), unit.getTable('returnTo')
    if stack.air then delay = returnStack(
        Global.call('getNewCommand', {nation = nation, force = 'air'}),
        stack.air, return_to, delay
    ) end
    if stack.army then delay = returnStack(
        Global.call('getNewCommand', {nation = nation, force = 'army'}),
        stack.army, return_to, delay
    ) end
    return delay
end

function getCommandStacks()
    local mode, commands, combatants = combatMode(), {axis = {cfighter = {}}, allies = {cfighter = {}}}, {}
    for _, obj in ipairs(Zones.commands.getObjects()) do
        if obj.getName() == 'arrow' then obj.destruct()
        else
            local nation, side = getColumn(obj), (mode == 'land') == (self.positionToLocal(obj.getPosition()).x > 0) and 'axis' or 'allies'
            commands[side][obj.getGUID()] = {command = obj, units = {}}
            addCombatant(nation, combatants)
    end end
    for side, stacks in pairs(commands) do
        for unit, stances in pairs(Zones.units[combatMode()][side]) do for _, zone in pairs(stances) do
            for _, obj in ipairs(zone.getObjects()) do
                local nation = obj.getVar('nation')
                if obj.getName() == 'cfighter' then
                    table.insert(stacks.cfighter, obj)
                    addCombatant(nation, combatants)
                elseif nation:match('neutral') then
                    nation = nation:match('neutral%-(%a+)')
                    debug('Found defense force ', obj.getName(), 'controlled by ', nation)
                    obj.setVar('nation', nation)
                    stacks.defense = stacks.defense or {}
                    if obj.getName() == 'fighter' then stacks.defense.air = {obj}
                    else
                        stacks.defense.army = stacks.defense.army or {}
                        table.insert(stacks.defense.army, obj)
                    end
                    addCombatant(nation, combatants)
                else
                    table.insert(stacks[obj.getVar('command')].units, obj)
                    obj.setVar('command', nil)
        end end end end
        if mode == 'sea' then for _, obj in ipairs(Zones.casualties[side].getObjects()) do
            if obj.getName() == 'submarine' and self.positionToLocal(obj.getPosition()).z < 0 then
                table.insert(stacks[obj.getVar('command')].units, obj)
                obj.setVar('command', nil)
    end end end end
    return commands, combatants
end

function addCombatant(nation, combatants)
    if not combatants[nation] then
        debug('Found ', nation, ' combatant')
        table.insert(combatants, nation)
        combatants[nation] = true
    end
end

function resetState()
    local mode = combatMode()
    self.UI.hide(mode .. '-status-panel')
    for _, side in ipairs{'axis', 'allies'} do self.UI.show(mode .. '-' .. side .. '-roll-frame') end
    onObjectEnterScriptingZone, onObjectLeaveScriptingZone = nil, nil
    state, AlertID = {}, 'Battle'
end
