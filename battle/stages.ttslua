function setupStage(stage)
    debug('Setting up ', stage, ' stage')
    local mode, rollers = combatMode()
    self.UI.setValue(mode .. '-status', stage:sub(1,1):upper() .. stage:sub(2) .. ' stage')
    for side, _ in pairs(state.dice) do
        self.UI.hide(mode .. '-' .. side .. '-' .. stage)
        if state.dice[side][stage] > 0 and (stage == 'bomb' or countStageUnits(other(side), stage) > 0) then
            if rollers then rollers = 'both' else rollers = side end
            setHotspotCounters(side, stage, math.min(state.dice[side][stage], 30))
        end
        state.dice[side][stage] = 0
    end
    if rollers == 'both' then
        startRound = function (_, _, id)
            local side = id:match('%-(%a+)%-')
            startRound = nil
            rollRound(stage, side, true)
        end
        for side, _ in pairs(state.dice) do
            self.UI.show(mode .. '-' .. side .. '-confirm-panel')
            self.UI.setAttributes(mode .. '-' .. side .. '-confirm', {
                text = 'Roll', interactable = true, onClick = 'startRound'
            })
        end
    elseif rollers then
        Wait.frames(|| rollRound(stage, rollers, nil, stage == 'bomb' and getBombTargets(rollers)), 20)
    else advanceStage(stage) end
end

function advanceStage(stage)
    if stage == 'air' then
        onObjectEnterScriptingZone, onObjectLeaveScriptingZone = nil, nil
        if combatMode() == 'land' then setupStage('bomb') else setupStage('surface') end
    elseif stage == 'bomb' then
        self.UI.hide('axis-bomb-targets')
        self.UI.hide('allies-bomb-targets')
        setupStage('ground')
    else makeRepairs() end
end

function setHotspotCounters(side, stage, num)
    local mode = combatMode()
    local y_sign = mode == 'land' and 1 or -1
    local y_inc, x_sign = 0.71 * y_sign, (side == 'axis' and 1 or -1) * y_sign
    local x, y, z_min = 1.5 * x_sign, 0.1 * (1 + y_sign) + y_inc / 2, ZoneParams.land.units.bomber.strategic
    local start = self.positionToWorld({(mode == 'land' and 0.95 or 0.89) * x_sign, y, ZoneParams[mode].commands})
    if stage == 'bomb' then while num > 0 do
        num = num - 4
        setHotspotCounter(start, self.positionToWorld({x, y, ZoneParams.land.units.armor.offensive}))
        y = y + y_inc
    end else
        setHotspotCounter(start, self.positionToWorld({x, y, (30 - num) % 10 * 0.173 + z_min}))
        if num % 10 == 0 then y = y + y_inc end
        if num > 10 then setHotspotCounter(start, self.positionToWorld({x, y, z_min})) end
        y = y + y_inc
        if num > 20 then setHotspotCounter(start, self.positionToWorld({x, y, z_min})) end
    end
end

function setHotspotCounter(start, moveTo) HotspotBag.takeObject({
    position = start, smooth = false,
    callback_function = |obj| Wait.condition(|| obj.setPositionSmooth(moveTo, false, true), || not obj.spawning)
}) end

function getBombTargets(side)
    local targets, colors = {}, Global.call('getBombTargets', {state.hotspot.getVar('region')})
    for _, target in ipairs(BombOrder) do if colors[target[1]][target[2]] then
        table.insert(targets, {color = target[1], target = target[2], qty = colors[target[1]][target[2]]})
    end end
    self.UI.show(side .. '-bomb-targets')
    for i = 1, 8 do if targets[i] then
        self.UI.setAttributes(side .. '-target' .. i, {
            text = targets[i].qty, textColor = targets[i].color == 'white' and 'red' or 'white',
            image = targets[i].target, active = true, interactable = false
        })
    else self.UI.hide(side .. '-target' .. i) end end
    return targets
end
