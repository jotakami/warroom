--- Battle board setup ---

function flipBoard()
    local sign = self.is_face_down and -1 or 1
    self.setPositionSmooth(self.getPosition() + vector(0, 0.2, 0) * sign)
    self.setRotationSmooth(self.getRotation() + vector(0, 0, 180) * sign)
end

function setupCombat(data)
    local setup = data[1]
    state.hotspot = data[2]
    local region = Global.call('getRegion', {state.hotspot}):gsub('([aimp])', '%1-'):upper()
    AlertID = 'Battle ' .. region
    debug('setup: ', setup, ', hotspot: ', state.hotspot.getGUID(), ', region: ', region)
    self.UI.setValue(setup .. '-region', region)
    self.UI.setAttribute(setup .. '-region', 'color', '#' .. (Colors[Prefixes[region:sub(1, 1):lower()] or 'sea']))
    if (setup == 'land') == self.is_face_down then
        flipBoard()
        Wait.condition(function ()
            adjustZones()
            adjustSnapPoints()
        end, || not self.isSmoothMoving())
    end
end

function loadZones()
    Zones = {
        commands = getObjectFromGUID(ZoneGUIDs.commands),
        units = {byGUID = {}},
        casualties = {
            axis = getObjectFromGUID(ZoneGUIDs.casualties.axis),
            allies = getObjectFromGUID(ZoneGUIDs.casualties.allies)
        }
    }
    for mode, sides in pairs(ZoneGUIDs.units) do
        Zones.units[mode] = {}
        Zones.units.byGUID[mode] = {}
        for side, units in pairs(sides) do
            Zones.units[mode][side] = {}
            for unit, stances in pairs(units) do
                Zones.units[mode][side][unit] = {}
                for stance, guid in pairs(stances) do
                    Zones.units[mode][side][unit][stance] = getObjectFromGUID(guid)
                    Zones.units.byGUID[mode][guid] = {side = side, unit = unit, stance = stance}
    end end end end
    adjustZones()
    adjustSnapPoints()
end

function adjustZones()
    local mode, sign, offset = combatMode(), self.is_face_down and -1 or 1, self.is_face_down and -0.02 or 0.22
    Zones.commands.setPosition(self.positionToWorld({0, offset + sign, ZoneParams[mode].commands}))
    for side, zone in pairs(Zones.casualties) do
        zone.setPosition(self.positionToWorld({ZoneParams[mode].sides[side].casualties, offset + 3 * sign, ZoneParams[mode].casualties}))
    end
    for side, units in pairs(Zones.units[mode]) do
        for unit, stances in pairs(units) do for stance, zone in pairs(stances) do
            zone.setPosition(self.positionToWorld({ZoneParams[mode].sides[side].units, offset + 1.5 * sign, ZoneParams[mode].units[unit][stance]}))
    end end end
end

function adjustSnapPoints()
    local snaps, mode = {}, combatMode()
    local rows = {{x = {}, z = ZoneParams[mode].commands}}
    for _, columns in pairs(ZoneParams[mode].sides) do for _, x in pairs(columns.nations) do table.insert(rows[1].x, x) end end
    if mode == 'sea' then table.insert(rows, {x = {-1.275, 1.27}, z = -0.365}) end
    for unit, stances in pairs(ZoneParams[mode].units) do for stance, z in pairs(stances) do
        local row = {x = {}, z = z}
        for side, columns in pairs(ZoneParams[mode].sides) do
            table.insert(row.x, columns.casualties)
            if mode == 'land' and (unit == 'armor' and stance == 'defensive')
              or mode == 'sea' and (unit == 'battleship' or unit == 'carrier') then
                table.insert(row.x, columns.sustained)
                table.insert(row.x, columns.damaged2)
            elseif unit ~= 'infantry' or stance ~= 'offensive' then table.insert(row.x, columns.damaged) end
            for nation, x in pairs(columns.nations) do
                if nation ~= 'china' or unit == 'infantry' or unit == 'artillery' then table.insert(row.x, x) end
        end end
        table.insert(rows, row)
    end end
    for _, row in ipairs(rows) do for _, x in ipairs(row.x) do table.insert(snaps, {
        position = {x, mode == 'land' and 0.2 or 0, row.z},
        rotation = {0, mode == 'sea' and row.z > -0.36 and 33 * x / math.abs(x) or 0, mode == 'land' and 0 or -180},
        rotation_snap = true
    }) end end
    self.setSnapPoints(snaps)
end

function isReady() return not state.hotspot end

function setStances()
    local mode, unit_types, ready = combatMode(), {}, {}
    self.UI.setAttribute(mode .. '-status-panel', 'active', true)
    self.UI.setValue(mode .. '-status', 'Set stances')
    state.dice = {}
    for side, zones in pairs(Zones.units[mode]) do
        self.UI.setAttribute(mode .. '-' .. side .. '-roll-frame', 'active', false)
        self.UI.setAttribute(mode .. '-' .. side .. '-confirm-panel', 'active', true)
        self.UI.setAttributes(mode .. '-' .. side .. '-confirm', {
            text = 'Ready?',
            onClick = 'stancesReady(' .. side .. ')',
            interactable = true
        })
        state.dice[side] = {}
        for stage, _ in pairs(CombatParams[mode].stages) do state.dice[side][stage] = 0 end
        unit_types[side] = 0
        for unit, stances in pairs(zones) do
            local has_unit = false
            for stance, zone in pairs(stances) do
                local count = countUnits(zone, unit)
                if count > 0 then
                    has_unit = true
                    addDice(state.dice[side], CombatParams[mode].units[unit][stance].dice, count)
                    updateDiceText(side)
            end end
            if has_unit and unit ~= 'fighter' and unit ~= 'bomber' then unit_types[side] = unit_types[side] + 1 end
    end end
    onObjectEnterScriptingZone = |zone, obj| updateUnitDice(zone, obj, 1)
    onObjectLeaveScriptingZone = |zone, obj| updateUnitDice(zone, obj, -1)
    stancesReady = function (_, side)
        ready[side] = true
        self.UI.setAttributes(mode .. '-' .. side .. '-confirm', {text = 'Ready', interactable = false})
        if ready.axis and ready.allies then
            stancesReady = nil
            setupStage('air')
    end end
    setForceAdvantage(unit_types.axis, unit_types.allies)
end

function getDropPoints()
    local mode, points = combatMode(), {x = {}, z = {}}
    points.y = 0.1 * (mode == 'land' and 2 or 0)
    points.z.command = ZoneParams[mode].commands
    for _, columns in pairs(ZoneParams[mode].sides) do for nation, x in pairs(columns.nations) do points.x[nation] = x end end
    for unit, stances in pairs(ZoneParams[mode].units) do
        points.z[unit] = stances.antiair or stances.air or stances.ground or stances.surface or stances.escort or stances.defensive or stances.dive
    end
    return points
end

--- Tracking dice totals ---

function updateUnitDice(zone, obj, count)
    local info = Zones.units.byGUID[combatMode()][zone.getGUID()]
    if info and obj.getName():find(info.unit) then
        addDice(state.dice[info.side], CombatParams[combatMode()].units[info.unit][info.stance].dice, count)
        updateDiceText(info.side)
    end
end

function addDice(totals, per_unit, units)
    for stage, n in pairs(totals) do totals[stage] = n + (per_unit[stage] or 0) * units end
end

function countUnits(zone, unit)
    local count = 0
    for _, obj in ipairs(zone.getObjects()) do if obj.getName():find(unit) then count = count + 1 end end
    return count
end

function countStageUnits(side, stage)
    local total, mode = 0, combatMode()
    for _, unit in pairs(CombatParams[mode].stages[stage]) do
        for stance, zone in pairs(Zones.units[mode][side][unit]) do total = total + countUnits(zone, unit) end
    end
    return total
end

function updateDiceText(side)
    for stage, value in pairs(state.dice[side]) do
        local id = combatMode() .. '-' .. side .. '-' .. stage
        if value > 0 then
            self.UI.show(id)
            self.UI.setValue(id .. '-dice', math.min(value, 30))
        else self.UI.hide(id) end
    end
end

--- Force and Port Advantage ---

function setForceAdvantage(axis, allies)
    local adv, mode = axis - allies, combatMode()
    if adv ~= 0 then
        local mode_sign = mode == 'land' and 1 or -1
        local side = math.abs(adv) / adv * mode_sign
        ArrowBag.takeObject({
            position = self.positionToWorld({0.12 * side, 2 * mode_sign, ZoneParams[combatMode()].commands - (mode == 'sea' and 0.06 or 0)}),
            rotation = self.getRotation() + vector(90 + 90 * side, 90 * mode_sign, 0),
            smooth = false
        })
    end
end

function checkForceAdvantage()
    for _, obj in ipairs(Zones.commands.getObjects()) do
        if obj.getName() == 'arrow' and (combatMode() == 'land' or self.positionToLocal(obj.getPosition()).z < ZoneParams.sea.commands) then
            if obj.is_face_down then return 'axis' else return 'allies' end
    end end
    return nil
end

function setPortAdvantage(side)
    if type(side) == 'table' then side = side[1] end
    local sign = side == 'axis' and -1 or 1
    if combatMode() == 'sea' then ArrowBag.takeObject({
        position = self.positionToWorld({0.12 * sign, -2, ZoneParams.sea.commands + 0.06}),
        rotation = self.getRotation() + vector(90 + 90 * sign, -90, 0),
        smooth = false
    }) end
    if countStageUnits(side, 'surface') > 0 then
        state.dice[side].surface = state.dice[side].surface + 2
        updateDiceText(side)
    end
end

function checkPortAdvantage(side)
    if combatMode() == 'sea' then for _, obj in ipairs(Zones.commands.getObjects()) do
        if obj.getName() == 'arrow' and self.positionToLocal(obj.getPosition()).z > ZoneParams.sea.commands then
            if (side == 'axis') == obj.is_face_down then return true end
    end end end
    return false
end
