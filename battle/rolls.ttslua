--- Roll dice ---

function rollRound(stage, side, switch, targets)
    local mode = combatMode()
    local num, more = getRollCounter(side)
    local callback = function ()
        local ready, wait_fun = mode ~= 'sea'
        if not ready then
            for _, unit in ipairs(Zones.units[mode][other(side)].submarine.dive.getObjects()) do
                if getColumn(unit) == 'damaged' then
                    unit.setPositionSmooth(self.positionToWorld({other(side) == 'axis' and -1.275 or 1.27, -0.63, -0.365}))
                    unit.setRotationSmooth({0, self.getRotation().y, 0})
                    wait_fun = Wait.condition(function () ready = true end, || not unit.isSmoothMoving())
                    break
            end end
            if not wait_fun then ready = true end
        end
        Wait.condition(function ()
            if switch or more then rollRound(stage, switch and other(side) or side, switch and more, targets)
            else advanceStage(stage)
        end end, || ready)
    end
    if stage ~= 'bomb' and countStageUnits(other(side), stage) == 0 then Wait.frames(|| callback(), 12)
    else
        setStatusRolling(side)
        rollDice(num, function (results)
            local a, b = 1, #results.objs
            while a < b do results.objs[a], results.objs[b], a, b = results.objs[b], results.objs[a], a + 1, b - 1 end
            if stage == 'bomb' then assignBombs(side, results.objs, targets, function ()
                assignBomb = nil
                callback()
            end) else assignHits(side, stage, results.objs, callback) end
    end) end
end

function setStatusRolling(side)
    local id = combatMode() .. '-' .. side .. '-confirm'
    self.UI.hide(id:gsub(side, other(side)) .. '-panel')
    self.UI.show(id .. '-panel')
    self.UI.setAttributes(id, {text = 'Rolling', interactable = false})
end

function getRollCounter(side)
    local mode, counter, more = combatMode()
    local y_sign = mode == 'land' and 1 or -1
    local x_sign = (side == 'axis' and 1 or -1) * y_sign
    local origin = self.positionToWorld({1.5 * x_sign, 0.1 + 0.455 * y_sign, -1.05})
    for _, obj in ipairs(Physics.cast({
        origin = origin, direction = self.getTransformForward(), max_distance = 15
    })) do if counter then
        more = true
        if obj.hit_object.getPosition():distance(origin) < counter.getPosition():distance(origin) then
            counter = obj.hit_object
    end else counter = obj.hit_object end end
    if not more then for _, _ in ipairs(Physics.cast({
        origin = counter.getPosition() + vector(0, 0.2, 0),
        direction = {0, 1, 0}, max_distance = 5
    })) do more = true end end
    local num = math.floor((16.3 - counter.getPosition():distance(origin)) / 1.47 + 0.1)
    counter.destruct()
    return num, more
end

function rollClick(_, _, id)
    local side, num = id:match('%a+%-roll%-(%a+)%-(%d+)$')
    alert(colorize(proper(side), side), '[-] rolling ', num, ' dice')
    rollDice(num + 0)
end

function rollDice(num, callback)
    local roll, i = {objs = {}}, 0
    if not callback then callback = || nil end
    Wait.time(function ()
        local bag, other = DieBags[i % 2 + 1], DieBags[(i + 1) % 2 + 1]
        local force = vector(
            bag.positionToLocal(other.getPosition()).x * (math.random() / 2.5 + 0.15),
            math.random() * 5 + 3,
            (math.random() - 0.5) * 5
        )
        rollDie(i + 1, bag, force, roll)
        i = i + 1
    end, 0.15, num)
    Wait.condition(function ()
        arrangeResults(roll)
        Wait.condition(|| callback(roll), || not roll.objs[num].isSmoothMoving())
    end, || roll.objs[num] ~= nil)
end

function rollDie(index, bag, force, results) bag.takeObject({
    position = bag.getPosition() + vector(0, 3, 0),
    rotation = vector(math.random(360), 0, math.random(360)),
    smooth = false,
    callback_function = function (obj)
        obj.use_gravity = false
        Wait.time(function ()
            obj.use_gravity = true
            obj.addForce(force)
            obj.addTorque({math.random() * 2, math.random() * 2, math.random() * 2})
            Wait.time(function () results.objs[index] = obj end, 3)
        end, 0.2)
end}) end

function arrangeResults(roll)
    local left, right = DieBags[1].getPosition() + vector(0, 0.5, 0), DieBags[2].getPosition() + vector(0, 0.5, 0)
    table.sort(roll.objs, |a, b| DiceOrder[getDieColor(a)] < DiceOrder[getDieColor(b)])
    roll.result = {}
    local msg = ''
    for i, die in ipairs(roll.objs) do
        roll.result[getDieColor(die)] = (roll.result[getDieColor(die)] or 0) + 1
        die.setPositionSmooth(left:lerp(right, 0.47 - #roll.objs * 0.03 + i * 0.06))
        die.setRotationSmooth(die.getRotationValues()[die.getValue()].rotation)
    end
    for color, num in pairs(roll.result) do msg = msg .. '[' .. Colors[color] .. ']' .. num .. '[-], ' end
    alert('Roll result: ' .. msg:sub(1, -6))
end

--- Assign hits ---

function assignBombs(side, dice, targets, callback)
    if #dice == 0 then
        for i, target in ipairs(targets) do toggleBombButton(side, i, false, target.color == 'white') end
        callback()
    else
        local die = table.remove(dice)
        local color, waiting = getDieColor(die)
        for i, target in ipairs(targets) do if (color == 'black' or color == target.color) and target.qty > 0 then
            waiting = true
            toggleBombButton(side, i, true, target.color == 'white')
        else toggleBombButton(side, i, false, target.color == 'white') end end
        if waiting then
            setBlinker(die)
            local region, pos = state.hotspot.getVar('region'), state.hotspot.getPosition() + vector(0, 1, 0)
            assignBomb = function (_, _, id)
                local index = id:match('%d+') + 0
                Global.call('bombHit', {region, targets[index].target, pos})
                stopBlinker(die)
                die.destruct()
                targets[index].qty = targets[index].qty - 1
                self.UI.setAttribute(side .. '-target' .. index, 'text', targets[index].qty)
                assignBombs(side, dice, targets, callback)
            end
        else
            die.destruct()
            assignBombs(side, dice, targets, callback)
    end end
end

function toggleBombButton(side, index, enable, bomb)
    self.UI.setAttributes(side .. '-target' .. index, {textColor = bomb and 'red' or 'white', interactable = enable})
end

function assignHits(side, stage, dice, callback)
    local fd, skips, waiting = checkForceAdvantage() == other(side)
    if stage == 'air' then skips = 'yellow,blue'
    elseif stage == 'ground' then skips = 'red'
    else skips = '' end
    if stage ~= 'air' and fd then skips = 'black,white,' .. skips end
    while #dice > 0 and not waiting do
        local die = table.remove(dice)
        local color = getDieColor(die)
        if skips:match(color) then die.destruct()
        else
            local targets = getTargets(side, stage, color)
            if #targets == 0 then
                die.destruct()
                skips = color .. ',' .. skips
            else
                waiting = true
                local hit_callback = || assignHits(side, stage, dice, callback)
                if #targets > 1 then createHitButtons(die, targets, hit_callback)
                else assignHit(targets[1], die, hit_callback) end
    end end end
    if #dice == 0 and not waiting then callback() end
end

function getTargets(side, stage, color)
    local mode, units, targets = combatMode(), {}, {}
    local escort, escort_targeted
    if color == 'black' or color == 'white' then
        for _, unit in pairs(CombatParams[mode].stages[stage]) do table.insert(units, unit) end
    else table.insert(units, CombatParams[mode].stages[stage][color]) end
    for _, unit in ipairs(units) do
        for stance, zone in pairs(Zones.units[combatMode()][other(side)][unit]) do
            for _, t in ipairs(getTarget(zone, unit, color == 'white')) do
                table.insert(targets, t)
                if unit == 'carrier' or unit == 'battleship' then escort = true end
                if stance == 'escort' then escort_targeted = true end
    end end end
    if escort and not escort_targeted then
        for _, t in ipairs(getTarget(Zones.units[combatMode()][other(side)].cruiser.escort, 'cruiser')) do table.insert(targets, t) end
    end
    return targets
end

function getTarget(zone, unit, white_hit)
    local units, targets = {}, {}
    for _, obj in ipairs(zone.getObjects()) do if obj.getName():match(unit) then
        local align = getColumn(obj)
        if not units[align] or isAbove(obj, units[align]) then units[align] = obj end
    end end
    if units['damaged'] and (unit ~= 'submarine' or not white_hit) then table.insert(targets, units['damaged'])
    elseif not white_hit then
        if units['sustained'] then table.insert(targets, units['sustained'])
        else for nation, obj in pairs(units) do table.insert(targets, obj) end end
    end
    return targets
end

function createHitButtons(die, targets, callback)
    setBlinker(die)
    for _, target in ipairs(targets) do
        setBlinker(target)
        createHitButton(target)
    end
    clickHit = function (_, guid)
        stopBlinker(die)
        for _, target in ipairs(targets) do
            stopBlinker(target)
            target.UI.setXml('')
        end
        assignHit(getObjectFromGUID(guid), die, || callback())
        clickHit = nil
    end
end

function createHitButton(obj) obj.UI.setXmlTable({{tag = 'Button', attributes = {
    position = '0 0 ' .. (obj.is_face_down and '2' or '-29'),
    rotation = '0 ' .. (obj.is_face_down and '180' or '0') .. ' 180',
    height = 48, width = 72, scale = obj.getName() == 'cfighter' and '2 2' or '1 1',
    fontSize = 36, text = 'Hit',
    color = '#' .. Colors[obj.getName()] .. 'd0|#ffffffd0|#000000d0|clear',
    onClick = self.getGUID() .. '/clickHit(' .. obj.getGUID() .. ')'
}}}) end

function assignHit(obj, die, callback)
    local mode, column, pos = combatMode(), getColumn(obj), self.positionToLocal(obj.getPosition())
    local side, y_sign = (mode == 'land') == (pos.x > 0) and 'axis' or 'allies', mode == 'land' and 1 or -1
    local unit, stance = getUnitStance(obj)
    local y, z = 0.1 * (1 + y_sign), ZoneParams[mode].units[unit][stance]
    if die then die.highlightOn({1, 1, 1, 0.7}) end
    if column == 'damaged' or CombatParams[mode].units[unit][stance].hp == 1 then
        pos = self.positionToWorld({ZoneParams[mode].sides[side].casualties, y, z})
        for _, collision in ipairs(Physics.cast({
            origin = pos - vector(0, 0.05, 0),
            direction = {0, 1, 0},
            max_distance = 4
        })) do pos = pos + vector(0, 0.22, 0) end
    else
        local x = ZoneParams[mode].sides[side].damaged
        if column == 'sustained' then x = ZoneParams[mode].sides[side].damaged2
        elseif CombatParams[mode].units[unit][stance].hp == 3 then x = ZoneParams[mode].sides[side].sustained end
        pos = self.positionToWorld({x, y, z})
    end
    obj.setPositionSmooth(pos + vector(0, obj.is_face_down and 0.21 or 0, 0))
    Wait.condition(function ()
        if die then die.destruct() end
        callback()
    end, || not obj.isSmoothMoving())
end
