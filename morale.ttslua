#include constants/morale
#include utils/debug

function onLoad(saved_state)
    Zones = {}
    for nation, guid in pairs(Global.getTable('GUIDs').MoraleZones) do Zones[nation] = getObjectFromGUID(guid) end
    local bag_guids = Global.getTable('GUIDs').Bags
    Bags = {
        Stress = {getObjectFromGUID(bag_guids.Stress[1]), nil, getObjectFromGUID(bag_guids.Stress[3])},
        MedalGoods = getObjectFromGUID(bag_guids.medal_goods)
    }
    state = {pending = {}, stress = {}, medals = {}}
    for nation, _ in pairs(Nations) do state.pending[nation] = {casualties = {}, stress = 0, medals = 0} end
    resetSnaps()
    resetUI()
end

function stackCasualties(data)
    for _, guid in ipairs(data) do
        local obj = getObjectFromGUID(guid)
        local unit = obj.getName()
        addCasualty(obj, obj.getVar('nation'), unit == 'cfighter' and 'fighter' or unit)
        obj.setVar('nation', nil)
    end
end

function addCasualty(obj, nation, unit)
    if not state.pending[nation].casualties[unit] then state.pending[nation].casualties[unit] = {} end
    local casualties = state.pending[nation].casualties[unit]
    table.insert(casualties, obj)
    if #casualties == 1 then stackCasualty(casualties, getDropPosition(nation, unit)) end
end

function stackCasualty(casualties, pos) if #casualties > 0 then
    local obj, offset, step = casualties[1], vector(0, 0, 0), 0.21
    if obj.getName() == 'cfighter' then step = 0.22 end
    if obj.is_face_down then offset = vector(0, step, 0) end
    obj.setPositionSmooth(pos + offset)
    obj.setRotationSmooth(self.getRotation() + vector(0, 0, obj.is_face_down and 180 or 0))
    Wait.frames(function ()
        table.remove(casualties, 1)
        stackCasualty(casualties, pos + vector(0, step, 0))
    end, 5)
end end

function getDropPosition(nation, unit)
    local pos, offset = self.positionToWorld(self.getSnapPoints()[snapOffset(nation, unit)].position) - vector(0, 0.1, 0), 0.15
    for _, obj in ipairs(Physics.cast({
        origin = pos, direction = {0, 1, 0}, max_distance = 5
    })) do offset = offset + (obj.hit_object.getName() == 'cfighter' and 0.22 or 0.21) end
    return pos + vector(0, offset, 0)
end

function getMedals(data)
    local medals = {}
    for _, obj in ipairs(Zones[data.nation].getObjects()) do
        if obj.getName() == 'medal_goods' then table.insert(medals, obj) end
    end
    table.sort(medals, function (a, b)
        local ay, by = a.getPosition().y, b.getPosition().y
        if a.is_face_down then ay = ay - a.getCustomObject().thickness end
        if b.is_face_down then by = by - b.getCustomObject().thickness end
        return ay < by
    end)
    return medals
end

function addMedals(data)
    debug('Giving ', data.value, ' ', data.goods and 'consumer goods' or 'medals', ' to ', data.nation)
    state.pending[data.nation].medals = state.pending[data.nation].medals + data.value
    if state.pending[data.nation].medals == data.value then
        local medal, position = table.remove(getMedals({nation = data.nation}))
        if medal then
            position = medal.getPosition()
            if medal.is_face_down then position = position - vector(0, 0.21, 0) end
        else position = self.positionToWorld(self.getSnapPoints()[snapOffset(data.nation, 'medal_goods')].position) end
        stackMedals(data.nation, position + vector(0, 2, 0), data.goods)
    end
end

function addGoods(data) addMedals({nation = data.nation, value = data.value, goods = true}) end

function stackMedals(nation, position, flipped) if state.pending[nation].medals > 0 then
    state.pending[nation].medals = state.pending[nation].medals - 1
    Bags.MedalGoods.takeObject({
        position = position + vector(0, flipped and 0.21 or 0, 0),
        rotation = self.getRotation() + vector(0, 0, flipped and 180 or 0),
        callback_function = || stackMedals(nation, position + vector(0, 0.21, 0), flipped)
}) end end

function getStress(data)
    local stress = {total = 0, objs = {}}
    for _, obj in ipairs(Zones[data.nation].getObjects()) do if not obj.isSmoothMoving() then
        if obj.getName() == '1stress' then
            stress.total = stress.total + 1
            table.insert(stress.objs, obj)
        elseif obj.getName() == '3stress' then
            stress.total = stress.total + 3
            table.insert(stress.objs, obj)
    end end end
    table.sort(stress.objs, function (a, b)
        local ay, by = a.getPosition().y, b.getPosition().y
        if a.is_face_down then ay = ay - a.getCustomObject().thickness end
        if b.is_face_down then by = by - b.getCustomObject().thickness end
        return ay < by
    end)
    return stress
end

function addStress(data)
    debug('Giving ', data.value, ' stress to ', data.nation)
    state.pending[data.nation].stress = state.pending[data.nation].stress + data.value
    if state.pending[data.nation].stress == data.value then
        local stress, singles, position = getStress(data), {}
        if #stress.objs == 0 then position = self.positionToWorld(self.getSnapPoints()[snapOffset(data.nation, 'stress')].position)
        else position = stress.objs[#stress.objs].getPosition() end
        if stress.total % 3 == 1 then singles = {stress.objs[#stress.objs]}
        elseif stress.total % 3 == 2 then singles = {stress.objs[#stress.objs - 1], stress.objs[#stress.objs]} end
        stackStress(data.nation, position + vector(0, 2, 0), singles)
    end
end

function stackStress(nation, position, singles)
    if state.pending[nation].stress > 0 then if #singles == 2 then Bags.Stress[1].takeObject({
        position = position, rotation = self.getRotation(),
        callback_function = placedCallback(function (obj)
            local pos = singles[2].getPosition()
            for _, o in pairs({obj, singles[2], singles[1]}) do destroyObject(o) end
            Bags.Stress[3].takeObject({position = pos, rotation = self.getRotation(), smooth = false})
            state.pending[nation].stress = state.pending[nation].stress - 1
            stackStress(nation, position - vector(0, 0.21, 0), {})
        end)
    })
    elseif #singles == 1 then placeStress(nation, 1, position, singles[1])
    elseif state.pending[nation].stress < 3 then placeStress(nation, 1, position)
    else placeStress(nation, 3, position) end end
end

function placeStress(nation, value, position, single)
    Bags.Stress[value].takeObject({
        position = position, rotation = self.getRotation(),
        callback_function = placedCallback(function (obj)
            local singles = {single}
            if value == 1 then table.insert(singles, obj) end
            state.pending[nation].stress = state.pending[nation].stress - value
            stackStress(nation, position + vector(0, 0.21, 0), singles)
    end)})
end

function placedCallback(callback)
    return |obj| Wait.condition(|| Wait.condition(|| callback(obj), || obj.getVelocity().y > -0.1), || obj.getVelocity().y < -0.1)
end

function convertCasualties()
    local ready = {}
    self.UI.hide('convert-button')
    self.UI.show('stress-levels')
    self.UI.show('casualties')
    for nation, _ in pairs(Nations) do
        ready[nation] = false
        self.UI.setValue(string.lower(nation) .. '-casualties', 0)
        self.UI.setAttribute(string.lower(nation) .. '-stress', 'image', 'stress-level0')
        countCasualties(nation, {total = 0, objs = sortCasualties(nation)}, 1, ready)
    end
    Wait.condition(|| self.UI.show('spend-button'), function ()
        for _, flag in pairs(ready) do if not flag then return false end end
        return true
    end)
end

function sortCasualties(nation)
    local units, name = {}
    for _, obj in ipairs(Zones[nation].getObjects()) do
        name = obj.getName()
        if name != 'medal_goods' and name != '1stress' and name != '3stress' then
            table.insert(units, obj)
    end end
    table.sort(units, function (a, b)
        if Spots[a.getName()] == Spots[b.getName()] then return a.getPosition()[2] > b.getPosition()[2]
        else return Spots[a.getName()] < Spots[b.getName()] end
    end)
    return units
end

function countCasualties(nation, casualties, i, ready)
    local obj, prev_total = casualties.objs[i], casualties.total
    if obj then
        casualties.total = casualties.total + Values[obj.getName()]
        destroyObject(obj)
        updateTotal(nation, casualties.total, prev_total)
        Wait.time(|| countCasualties(nation, casualties, i + 1, ready), 0.2)
    else
        ready[nation] = true
        announceCasualtyStress(nation, casualties.total)
    end
end

function announceCasualtyStress(nation, total)
    local level, shade
    for i, threshold in ipairs(Levels) do if total >= threshold then level, shade = i - 1, Shades[i] end end
    broadcastToAll(nation .. ' took [' .. shade .. ']' .. level .. '[-] stress from casualties')
end

function updateTotal(nation, total, prev_total)
    local level, prev_level
    for i, threshold in ipairs(Levels) do
        if total >= threshold then level = i - 1 end
        if prev_total >= threshold then prev_level = i - 1 end
    end
    self.UI.setValue(string.lower(nation) .. '-casualties', total)
    if level > prev_level then
        self.UI.setAttribute(string.lower(nation) .. '-stress', 'image', 'stress-level' .. level)
        addStress({nation = nation, value = level - prev_level})
    end
end

function spendMedals()
    self.UI.hide('spend-button')
    self.UI.hide('stress-levels')
    self.UI.hide('casualties')
    self.UI.show('thresholds')
    UI.setValue('step', 'Spend medals to cancel stress')
    UI.setValue('help-text', Global.getTable('HelpText').medals)
    Global.call('resetStatus')
    local ready = {}
    doneSpending = function (nation)
        ready[nation] = true
        local all_ready = true
        for _, flag in pairs(ready) do all_ready = all_ready and flag end
        if all_ready then
            debug('All nations are done spending medals')
            self.UI.hide('thresholds')
            Wait.time(evaluateStress, 1)
    end end
    for nation, _ in pairs(Nations) do
        ready[nation] = false
        state.stress[nation], state.medals[nation] = getStress({nation = nation}), getMedals({nation = nation})
        updateThreshold(nation)
        Wait.frames(|| updateSpendButton(nation, 1), 1)
    end
end

function spendMedal(_, value, id)
    if id == 'done' then
        debug(value, 'clicked done button')
        updateSpendButton(value)
        doneSpending(value)
    else
        debug(id, ' spent ' .. value .. ' medal(s)')
        for i = 1, value do
            local medal = table.remove(state.medals[id])
            medal.UI.setXml('')
            medal.destruct()
        end
        if tonumber(value) > 1 then
            Global.call('updateStressZone', {id, -1})
            doneSpending(id)
        else
            state.stress[id].total = state.stress[id].total - value
            updateThreshold(id)
            fadeOut(table.remove(state.stress[id].objs), function (obj)
                if obj.getName():find('3') then
                    local obj1, obj2 = makeChange(obj, 2)
                    table.insert(state.stress[id].objs, obj1)
                    table.insert(state.stress[id].objs, obj2)
                else obj.destruct() end
                updateSpendButton(id, tonumber(value))
            end)
    end end
end

function updateThreshold(nation)
    local id, value, color = nation .. '-threshold', state.stress[nation].total
    self.UI.setValue(id, value == 0 and '' or value .. '/')
    if value >= Thresholds[self.is_face_down and 2 or 1][nation] then color = '#ff8040' else color = '#ffffff' end
    self.UI.setAttribute(id, 'color', color)
end

function updateSpendButton(nation, num)
    local count, done = #state.medals[nation], false
    if count > 0 then
        local top = state.medals[nation][count]
        if num and count >= num then
            local cg = top.is_face_down
            if num > 1 or state.stress[nation].total > 0 then
                local rotation, z = '0 ' .. (cg and '180' or '0') .. ' 180', cg and '0.1' or '-20.8'
                top.UI.setXmlTable({
                    {tag = 'Button', attributes = {id = nation,
                        height = 60, width = 150, position = '0 -32 ' .. z, rotation = rotation,
                        text = 'Spend ' .. num, fontSize = 32, fontStyle = "Bold",
                        colors = (cg and '#609040|#a0c080' or 'orange|yellow') .. '|white|clear',
                        onClick = self.getGUID() .. '/spendMedal(' .. num .. ')'}},
                    {tag = 'Button', attributes = {id = 'done',
                        height = 60, width = 150, position = '0 32 ' .. z, rotation = rotation,
                        text = 'Done', fontSize = 32, colors = '#ffffff80|white|white|clear',
                        onClick = self.getGUID() .. '/spendMedal(' .. nation .. ')'}}})
            else done = true end
        else top.UI.setXml('') end
    else done = true end
    if done then debug(nation, ' can\'t spend, marking done') doneSpending(nation) end
end

function evaluateStress()
    Global.call('updateTracker', {'Evaluate homeland stress levels'})
    for nation, _ in pairs(Nations) do convertStress(nation) end
    Wait.time(relieveStress, 3)
end

function convertStress(nation)
    local stress, threshold = getStress({nation = nation}), getThreshold(nation)
    local count, remaining, delta = #stress.objs, threshold * 5, 5
    while stress.total < remaining do remaining, delta = remaining - threshold, delta - 1 end
    while remaining > 0 do
        local obj = stress.objs[count]
        count = count - 1
        if obj.getName() == '1stress' then
            remaining = remaining - 1
            fadeOut(obj)
        else
            remaining = remaining - 3
            if remaining < 0 then fadeOut(obj, |obj| makeChange(obj, -remaining))
            else fadeOut(obj) end
    end end
    if delta > 0 then Global.call('updateStressZone', {nation, delta}) end
end

function relieveStress()
    Global.call('updateTracker', {'Relieve homeland stress'})
    local ready = {}
    doneSpending = function (nation)
        if nation then ready[nation] = true end
        local all_ready = true
        for _, flag in pairs(ready) do all_ready = all_ready and flag end
        if all_ready then
            debug('All nations are done spending medals')
            doneSpending = nil
            Wait.time(|| Global.call('applyStressPenalties'), 2)
    end end
    for nation, _ in pairs(Nations) do
        ready[nation] = false
        if Global.call('getStressZone', {nation}) > 1 then Wait.frames(|| updateSpendButton(nation, getThreshold(nation)), 1)
        else Wait.frames(|| doneSpending(nation), 1) end
    end
end

function makeChange(obj, remaining)
    local params = {position = obj.getPosition(), rotation = {0, 180, 0}, smooth = false}
    local params2 = {
        position = params.position + obj.getTransformUp() * obj.getCustomObject().thickness * 1.1,
        rotation = {0, 180, 0},
        smooth = false
    }
    obj.destruct()
    local obj1 = Bags.Stress[1].takeObject(params)
    if remaining == 2 then return obj1, Bags.Stress[1].takeObject(params2) else return obj1 end
end

function fadeOut(obj, callback)
    callback = callback or |obj| obj.destruct()
    obj.UI.setXml('<Panel id="shade" height="200" width="200" position="0 0 -21" color="rgba(0.4,0.2,0,0)" />')
    Wait.time(function () if obj.getColorTint().b < 0.1 then callback(obj) else darken(obj) end end, 0.1, 10)
end

function darken(obj)
    local tint = obj.getColorTint()
    local color, a = obj.UI.getAttribute('shade', 'color')
    if color then
        color, a = color:match('(.+),(%d%.?%d*)%)$')
        obj.UI.setAttribute('shade', 'color', color .. ',' .. (a + 0.09) .. ')')
    end
    tint.r = tint.r - 0.05
    tint.g = tint.g - 0.08
    tint.b = tint.b - 0.1
    obj.setColorTint(tint)
end

function getThreshold(nation) return Thresholds[self.is_face_down and 2 or 1][nation] end

function snapOffset(nation, spot) return 1 + Nations[nation] * 11 + Spots[spot] end

function flipBoard()
    self.setPositionSmooth(self.getPosition() + vector(0, 0.2, 0))
    self.setRotationSmooth({0, 0, 180})
    Wait.condition(function ()
        resetUI()
        resetSnaps()
    end, || not self.isSmoothMoving())
end

function resetUI()
    local xml, flipped = self.UI.getXmlTable(), self.is_face_down
    for _, element in ipairs(xml) do if element.tag == 'Defaults' then
        for _, default in ipairs(element.children) do
            if default.attributes.class == 'stress' then flipPosition(default, flipped) end
            if default.attributes.rotation then default.attributes.rotation = '180 ' .. (flipped and 0 or 180) .. ' 0'
        end end
    elseif element.attributes.id:find('button') then flipPosition(element, flipped) end end
    self.UI.setXmlTable(xml)
end

function flipPosition(element, flipped)
    local xy = element.attributes.position:match('^%-?(%d*%.?%d+%s%-?%d*%.?%d+%s)')
    element.attributes.position = flipped and '-' .. xy .. '0.1' or xy .. '-20.1'
end

function resetSnaps()
    local snaps, flipped = {}, self.is_face_down
    for i, row in ipairs(Snaps.rows) do for j, col in ipairs(Snaps.cols) do
        if i < 7 or j < 6 then table.insert(snaps, {
            position = {flipped and -col or col, flipped and 0 or 0.2, row},
            rotation = {0, 0, flipped and 180 or 0},
            rotation_snap = true
        }) end
    end end
    self.setSnapPoints(snaps)
end
