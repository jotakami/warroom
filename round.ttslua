Round = {}
setmetatable(Round, {__call = function (t, ...)
    if t.resume == nil then
        t.resume = coroutine.wrap(|...| t:main(...))
        t.resume(...)
    else t.resume() end
end})

function Round:main()
    if state.phase < 1 then
        HUD.updateTracker('', '', 'start')
        HUD.resetStatus()
        UI.show('start')
        coroutine.yield()
        UI.hide('start')
        state.round = state.round + 1
        if state.round > 1 then HUD.close('production') end
        for i, nation in turnOrder() do
            Tokens.turn[nation].setPositionSmooth(Map.positionToWorld(Map.snaps[i].position:lerp(Map.center, 0.225)))
            Tokens.turn[nation].setRotationSmooth(Map.snaps[i].rotation + Map.rotation)
            Orders[nation]:newRound(state.round)
    end end
    UI.setValue('round', state.round)
    for nation, orders in ipairs(Orders) do
        orders.UI.setValue('round', state.round)
        if orders.not_china then orders.UI.hide('bid') end
    end
    if state.phase < 2 then Economy(self.resume) end
    Planning(self.resume)
    Movement(self.resume)
    if state.phase < 5 then Combat(self.resume) end
    if state.phase < 6 then Refit(self.resume) end
    if state.phase < 7 then Morale(self.resume) end
    Production(self.resume)
    local ps, commands = {}
    for _, nation in turnOrder() do if Morale.stressZone(nation) == 6 then
        local collapsed = true
        for _, command in pairs(Commands[nation]) do if command.units() > 0 then collapsed = false break end end
        if collapsed then
            broadcastToAll(Nations[nation].name .. ' has collapsed!', Color.orange)
            Resources[nation]:set({oil = 0, iron = 0, osr = 0})
            for id, region in pairs(Map.regions) do if id:match('^' .. Nations[nation].prefix) then
                region.collapsed = true
                local p = region.card:embattled(true)
                if region:owner() == nation then
                    commands = commands or Commands:byRegion()
                    local claimants = {}
                    for _, command in ipairs(Commands[id][region:side()]) do
                        if not claimants[command.nation] then table.insert(claimants, command.nation) end
                        claimants[command.nation] = true
                    end
                    if #claimants > 1 then
                        -- show buttons to choose new owner
                        alert('Choose new owner in ', region:colorizedName())
                        table.insert(ps, p)
                    elseif #claimants == 1 then table.insert(ps, p:next(region.card:giveTo(claimants[1]))) end
                else table.insert(ps, p) end
    end end end end end
    if #ps > 0 then
        Promise.all(ps):next(|| self.resume())
        coroutine.yield()
    end
    state.phase, self.resume = 0, nil
    Wait.time(|| Round(), 1)
end

Phase = {}
setmetatable(Phase, {__call = function (t, meta)
    local p = {}
    meta = meta or {}
    meta.__call = t.main
    setmetatable(p, meta)
    return p
end})

function Phase.main(t, co, ...)
    if rawget(t, 'resume') == nil then
        t.resume = co
        t:main(...)
    else t.resume(...) end
end

function Phase.readyLoop(readied, initial, fun)
    local all_ready = initial or false
    while not all_ready do
        local nation, ready = coroutine.yield()
        if fun == nil or fun(nation, ready) ~= false then
            readied[nation], all_ready = ready, true
            HUD.updateStatus(nation, ready)
            for _, r in pairs(readied) do all_ready = all_ready and r end
        else Wait.frames(|| Orders[nation]:toggleReady(false), 1) end
    end
    for nation, _ in pairs(readied) do Orders[nation].UI.hide('ready') end
end

turnOrder = {get = function ()
    local turns = {}
    for nation, token in pairs(Tokens.turn) do table.insert(turns, {
        nation = nation, angle = (Map:rotationToCenter(Map.positionToLocal(token.getPosition())) + 60) % 360
    }) end
    table.sort(turns, |a, b| a.angle > b.angle)
    for i = 1, #turns do turns[turns[i].nation], turns[i] = i, turns[i].nation end
    return turns
end}
setmetatable(turnOrder, {
    __call = |t| ipairs(t.get()),
    __index = |t, k| t.get()[k]
})
